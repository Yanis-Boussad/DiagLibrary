/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.2-pre4, Date: 04-Apr-2013.
 */
#include "TS24008Msgs.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxBitDecode.h"
#include "rtxsrc/rtxIntDecode.h"
#include "rtxsrc/rtx3GPP.h"
#include "rtxsrc/rtxDiagBitTrace.h"

EXTERN int NASDec_TS24008Msg_StartDTMF (OSCTXT* pctxt
   , TS24008Msg_StartDTMF* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "StartDTMF");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 44: {
               if (lastRow == 0) {
                  /* decode keypadFacility */
                  RTXCTXTPUSHELEMNAME (pctxt, "keypadFacility");

                  ret = NASDec_TS24008IE_KeypadFacilityInfo (pctxt, &pvalue->
                     keypadFacility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.keypadFacilityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_StartDTMFAck (OSCTXT* pctxt
   , TS24008Msg_StartDTMFAck* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "StartDTMFAck");

   ret = NASDec_TS24008Msg_StartDTMF (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivatePDPCtxtReject (OSCTXT* pctxt
   , TS24008Msg_ActivatePDPCtxtReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivatePDPCtxtReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode smCause */

   RTXCTXTPUSHELEMNAME (pctxt, "smCause");

   ret = NASDec_TS24008IE_SMCauseValue (pctxt, &pvalue->smCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateSecondaryPDPCtxtRej (OSCTXT* pctxt
   , TS24008Msg_ActivateSecondaryPDPCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateSecondaryPDPCtxtRej");

   ret = NASDec_TS24008Msg_ActivatePDPCtxtReject (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RequestPDPCtxtActRej (OSCTXT* pctxt
   , TS24008Msg_RequestPDPCtxtActRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestPDPCtxtActRej");

   ret = NASDec_TS24008Msg_ActivatePDPCtxtReject (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyPDPCtxtRej (OSCTXT* pctxt
   , TS24008Msg_ModifyPDPCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyPDPCtxtRej");

   ret = NASDec_TS24008Msg_ActivatePDPCtxtReject (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RqstSecondaryPDPCtxtActRej (OSCTXT* pctxt
   , TS24008Msg_RqstSecondaryPDPCtxtActRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RqstSecondaryPDPCtxtActRej");

   ret = NASDec_TS24008Msg_ActivatePDPCtxtReject (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateMBMSCtxtRej (OSCTXT* pctxt
   , TS24008Msg_ActivateMBMSCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateMBMSCtxtRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode smCause */

   RTXCTXTPUSHELEMNAME (pctxt, "smCause");

   ret = NASDec_TS24008IE_SMCauseValue (pctxt, &pvalue->smCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 53: {
               if (lastRow == 0) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RequestMBMSCtxtActRej (OSCTXT* pctxt
   , TS24008Msg_RequestMBMSCtxtActRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestMBMSCtxtActRej");

   ret = NASDec_TS24008Msg_ActivateMBMSCtxtRej (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthenticationRequest (OSCTXT* pctxt
   , TS24008Msg_AuthenticationRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthenticationRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ciphKeySeqNum */

   RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->ciphKeySeqNum);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode authParamRAND */

   RTXCTXTPUSHELEMNAME (pctxt, "authParamRAND");

   ret = NASDec_TS24008IE_AuthParamRAND (pctxt, &pvalue->authParamRAND);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 32: {
               if (lastRow == 0) {
                  /* decode authParamAUTN */
                  RTXCTXTPUSHELEMNAME (pctxt, "authParamAUTN");

                  ret = NASDec_TS24008IE_AuthParamAUTN (pctxt, &pvalue->
                     authParamAUTN);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authParamAUTNPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthenticationResponse (OSCTXT* pctxt
   , TS24008Msg_AuthenticationResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthenticationResponse");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode respParam */

   RTXCTXTPUSHELEMNAME (pctxt, "respParam");

   ret = NASDec_TS24008IE_AuthRespParam (pctxt, &pvalue->respParam);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 33: {
               if (lastRow == 0) {
                  /* decode respParamExt */
                  RTXCTXTPUSHELEMNAME (pctxt, "respParamExt");

                  ret = NASDec_TS24008IE_AuthRespParamExt (pctxt, &pvalue->
                     respParamExt);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.respParamExtPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthenticationFailure (OSCTXT* pctxt
   , TS24008Msg_AuthenticationFailure* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthenticationFailure");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode rejectCause */

   RTXCTXTPUSHELEMNAME (pctxt, "rejectCause");

   ret = NASDec_TS24008IE_RejectCauseValue (pctxt, &pvalue->rejectCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 34: {
               if (lastRow == 0) {
                  /* decode failParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "failParam");

                  ret = NASDec_TS24008IE_AuthFailureParam (pctxt, &pvalue->
                     failParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.failParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CMReestabRequest (OSCTXT* pctxt
   , TS24008Msg_CMReestabRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CMReestabRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ciphKeySeqNum */

   RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->ciphKeySeqNum);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileStationClassmark2 */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark2");

   ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &pvalue->
      mobileStationClassmark2);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 19: {
               if (lastRow == 0) {
                  /* decode locAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->
                     locAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.locAreaIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 13: {
               if (lastRow <= 1) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CMServicePrompt (OSCTXT* pctxt
   , TS24008Msg_CMServicePrompt* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CMServicePrompt");

   /* decode pdAndSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "pdAndSAPI");

   ret = NASDec_TS24008IE_PDAndSAPI (pctxt, &pvalue->pdAndSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CMServiceReject (OSCTXT* pctxt
   , TS24008Msg_CMServiceReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CMServiceReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode rejectCause */

   RTXCTXTPUSHELEMNAME (pctxt, "rejectCause");

   ret = NASDec_TS24008IE_RejectCauseValue (pctxt, &pvalue->rejectCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Abort (OSCTXT* pctxt, TS24008Msg_Abort* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Abort");

   /* decode rejectCause */

   RTXCTXTPUSHELEMNAME (pctxt, "rejectCause");

   ret = NASDec_TS24008IE_RejectCauseValue (pctxt, &pvalue->rejectCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CMServiceRequest (OSCTXT* pctxt
   , TS24008Msg_CMServiceRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CMServiceRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode ciphKeySeqNum */

   RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->ciphKeySeqNum);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cmServiceType */

   RTXCTXTPUSHELEMNAME (pctxt, "cmServiceType");

   ret = NASDec_TS24008IE_CMServiceType (pctxt, &pvalue->cmServiceType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileStationClassmark2 */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark2");

   ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &pvalue->
      mobileStationClassmark2);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8 || nibble == 12 || nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 8: {
               if (lastRow == 0) {
                  /* decode priorityLevel */
                  RTXCTXTPUSHELEMNAME (pctxt, "priorityLevel");

                  ret = NASDec_TS24008IE_PriorityLevel (pctxt, &pvalue->
                     priorityLevel);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.priorityLevelPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 1) {
                  /* decode addnUpdateParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateParams");

                  ret = NASDec_TS24008IE_AddnUpdateParams (pctxt, &pvalue->
                     addnUpdateParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateParamsPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 2) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_IdentityRequest (OSCTXT* pctxt
   , TS24008Msg_IdentityRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentityRequest");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   ret = NASDec_TS24008IE_IdentityTypeValue (pctxt, &pvalue->value);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_IdentityResponse (OSCTXT* pctxt
   , TS24008Msg_IdentityResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentityResponse");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 14) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 14: {
               if (lastRow == 0) {
                  /* decode p-TMSI-Type */
                  RTXCTXTPUSHELEMNAME (pctxt, "p-TMSI-Type");

                  ret = NASDec_TS24008IE_P_TMSI_Type (pctxt, &pvalue->
                     p_TMSI_Type);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.p_TMSI_TypePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 27: {
               if (lastRow <= 1) {
                  /* decode routingAreaId */
                  RTXCTXTPUSHELEMNAME (pctxt, "routingAreaId");

                  ret = NASDec_TS24008IE_RoutingAreaIdent2 (pctxt, &pvalue->
                     routingAreaId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.routingAreaIdPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 25: {
               if (lastRow <= 2) {
                  /* decode pTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature2 (pctxt, &pvalue->
                     pTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSISignaturePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_IMSIDetachInd (OSCTXT* pctxt
   , TS24008Msg_IMSIDetachInd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IMSIDetachInd");

   /* decode mobileStationClassmark1 */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark1");

   ret = NASDec_TS24008IE_MobileStationClassmark1 (pctxt, &pvalue->
      mobileStationClassmark1);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_LocUpdatingAccept (OSCTXT* pctxt
   , TS24008Msg_LocUpdatingAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LocUpdatingAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode locAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

   ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->locAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 23: {
               if (lastRow == 0) {
                  /* decode mobileIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     mobileIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileIdentityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 161: {
               if (lastRow <= 1) {
                  /* decode followOnProceed */
                  RTXCTXTPUSHELEMNAME (pctxt, "followOnProceed");

                  pvalue->m.followOnProceedPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 183;
               }
               break;
            }
            case 162: {
               if (lastRow <= 2) {
                  /* decode ctsPermission */
                  RTXCTXTPUSHELEMNAME (pctxt, "ctsPermission");

                  pvalue->m.ctsPermissionPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 183;
               }
               break;
            }
            case 74: {
               if (lastRow <= 3) {
                  /* decode equivPLMNs */
                  RTXCTXTPUSHELEMNAME (pctxt, "equivPLMNs");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->equivPLMNs
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.equivPLMNsPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 4) {
                  /* decode emergNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergNumList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergNumListPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 5) {
                  /* decode per-MS-T3212 */
                  RTXCTXTPUSHELEMNAME (pctxt, "per-MS-T3212");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     per_MS_T3212);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.per_MS_T3212Present = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_LocUpdatingReject (OSCTXT* pctxt
   , TS24008Msg_LocUpdatingReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LocUpdatingReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode rejectCause */

   RTXCTXTPUSHELEMNAME (pctxt, "rejectCause");

   ret = NASDec_TS24008IE_RejectCauseValue (pctxt, &pvalue->rejectCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 54: {
               if (lastRow == 0) {
                  /* decode t3246Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3246Value");

                  ret = NASDec_TS24008IE_MMTimer (pctxt, &pvalue->t3246Value);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3246ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_LocUpdatingRequest (OSCTXT* pctxt
   , TS24008Msg_LocUpdatingRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LocUpdatingRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode ciphKeySeqNum */

   RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->ciphKeySeqNum);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode locUpdatingType */

   RTXCTXTPUSHELEMNAME (pctxt, "locUpdatingType");

   ret = NASDec_TS24008IE_LocationUpdatingType (pctxt, &pvalue->locUpdatingType
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode locAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

   ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->locAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileStationClassmark1 */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark1");

   ret = NASDec_TS24008IE_MobileStationClassmark1 (pctxt, &pvalue->
      mobileStationClassmark1);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12 || nibble == 13 || nibble == 14) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 51: {
               if (lastRow == 0) {
                  /* decode mobStatCmark4UMTS */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobStatCmark4UMTS");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->mobStatCmark4UMTS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobStatCmark4UMTSPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 1) {
                  /* decode addnUpdateParams */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateParams");

                  ret = NASDec_TS24008IE_AddnUpdateParams (pctxt, &pvalue->
                     addnUpdateParams);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateParamsPresent = 1;
                  pvalue->m._v9ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 2) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 14: {
               if (lastRow <= 3) {
                  /* decode msNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetFeatureSupport");

                  ret = NASDec_TS24008IE_MSNetFeatureSupport (pctxt, &pvalue->
                     msNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetFeatureSupportPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_MMInformation (OSCTXT* pctxt
   , TS24008Msg_MMInformation* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MMInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 67: {
               if (lastRow == 0) {
                  /* decode networkFullName */
                  RTXCTXTPUSHELEMNAME (pctxt, "networkFullName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     networkFullName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.networkFullNamePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 69: {
               if (lastRow <= 1) {
                  /* decode networkShortName */
                  RTXCTXTPUSHELEMNAME (pctxt, "networkShortName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     networkShortName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.networkShortNamePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 70: {
               if (lastRow <= 2) {
                  /* decode localTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "localTimeZone");

                  ret = NASDec_TS24008IE_TimeZone (pctxt, &pvalue->
                     localTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.localTimeZonePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 71: {
               if (lastRow <= 3) {
                  /* decode univAndLocalTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "univAndLocalTimeZone");

                  ret = NASDec_TS24008IE_TimeZoneAndTime (pctxt, &pvalue->
                     univAndLocalTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.univAndLocalTimeZonePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 7;
               }
               break;
            }
            case 72: {
               if (lastRow <= 4) {
                  /* decode lsaIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "lsaIdentity");

                  ret = NASDec_TS24008IE_LSAIdentifier (pctxt, &pvalue->
                     lsaIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lsaIdentityPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 73: {
               if (lastRow <= 5) {
                  /* decode networkDaylightSavingTime */
                  RTXCTXTPUSHELEMNAME (pctxt, "networkDaylightSavingTime");

                  ret = NASDec_TS24008IE_DaylightSavingTime (pctxt, &pvalue->
                     networkDaylightSavingTime);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.networkDaylightSavingTimePresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_MMStatus (OSCTXT* pctxt
   , TS24008Msg_MMStatus* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "MMStatus");

   /* decode rejectCause */

   RTXCTXTPUSHELEMNAME (pctxt, "rejectCause");

   ret = NASDec_TS24008IE_RejectCauseValue (pctxt, &pvalue->rejectCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_TMSIReallocCmd (OSCTXT* pctxt
   , TS24008Msg_TMSIReallocCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TMSIReallocCmd");

   /* decode locAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

   ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->locAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Alerting (OSCTXT* pctxt
   , TS24008Msg_Alerting* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Alerting");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 28: {
               if (lastRow == 0) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 30: {
               if (lastRow <= 1) {
                  /* decode progressInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

                  ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->
                     progressInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.progressIndPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 2) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 3) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CallConfirmed (OSCTXT* pctxt
   , TS24008Msg_CallConfirmed* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CallConfirmed");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode repeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "repeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     repeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.repeatIndPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 4: {
               if (lastRow <= 1) {
                  /* decode bearerCap1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap1");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap1Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 2) {
                  /* decode bearerCap2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap2");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap2Present = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 8: {
               if (lastRow <= 3) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 21: {
               if (lastRow <= 4) {
                  /* decode callCtrlCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "callCtrlCap");

                  ret = NASDec_TS24008IE_CallControlCapabilities (pctxt, &
                     pvalue->callCtrlCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.callCtrlCapPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 45: {
               if (lastRow <= 5) {
                  /* decode streamId */
                  RTXCTXTPUSHELEMNAME (pctxt, "streamId");

                  ret = NASDec_TS24008IE_StreamIdentifierValue (pctxt, &pvalue
                     ->streamId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.streamIdPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 6) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CallProceeding (OSCTXT* pctxt
   , TS24008Msg_CallProceeding* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CallProceeding");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13 || nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode repeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "repeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     repeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.repeatIndPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 4: {
               if (lastRow <= 1) {
                  /* decode bearerCap1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap1");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap1Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 2) {
                  /* decode bearerCap2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap2");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap2Present = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 28: {
               if (lastRow <= 3) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 30: {
               if (lastRow <= 4) {
                  /* decode progressInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

                  ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->
                     progressInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.progressIndPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 8: {
               if (lastRow <= 5) {
                  /* decode priorityGranted */
                  RTXCTXTPUSHELEMNAME (pctxt, "priorityGranted");

                  ret = NASDec_TS24008IE_PriorityLevel (pctxt, &pvalue->
                     priorityGranted);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.priorityGrantedPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 47: {
               if (lastRow <= 6) {
                  /* decode netCallCtrlCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "netCallCtrlCap");

                  ret = NASDec_TS24008IE_NetCallCtrlCaps (pctxt, &pvalue->
                     netCallCtrlCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netCallCtrlCapPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CongestionControl (OSCTXT* pctxt
   , TS24008Msg_CongestionControl* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CongestionControl");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode congestionLevel */

   RTXCTXTPUSHELEMNAME (pctxt, "congestionLevel");

   ret = NASDec_TS24008IE_CongestionLevel (pctxt, &pvalue->congestionLevel);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 8: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Connect (OSCTXT* pctxt, TS24008Msg_Connect* pvalue
   )
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Connect");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 28: {
               if (lastRow == 0) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 30: {
               if (lastRow <= 1) {
                  /* decode progressInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

                  ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->
                     progressInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.progressIndPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 76: {
               if (lastRow <= 2) {
                  /* decode connNumber */
                  RTXCTXTPUSHELEMNAME (pctxt, "connNumber");

                  ret = NASDec_TS24008IE_ConnectedNumber (pctxt, &pvalue->
                     connNumber);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.connNumberPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 77: {
               if (lastRow <= 3) {
                  /* decode connSubaddr */
                  RTXCTXTPUSHELEMNAME (pctxt, "connSubaddr");

                  ret = NASDec_TS24008IE_ConnectedSubaddress (pctxt, &pvalue->
                     connSubaddr);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.connSubaddrPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 4) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 5) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 45: {
               if (lastRow <= 6) {
                  /* decode streamId */
                  RTXCTXTPUSHELEMNAME (pctxt, "streamId");

                  ret = NASDec_TS24008IE_StreamIdentifierValue (pctxt, &pvalue
                     ->streamId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.streamIdPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Disconnect (OSCTXT* pctxt
   , TS24008Msg_Disconnect* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Disconnect");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 28: {
               if (lastRow == 0) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 30: {
               if (lastRow <= 1) {
                  /* decode progressInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

                  ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->
                     progressInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.progressIndPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 2) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 123: {
               if (lastRow <= 3) {
                  /* decode allowedActions */
                  RTXCTXTPUSHELEMNAME (pctxt, "allowedActions");

                  ret = NASDec_TS24008IE_AllowedActions (pctxt, &pvalue->
                     allowedActions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allowedActionsPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 4) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_EmergencySetup (OSCTXT* pctxt
   , TS24008Msg_EmergencySetup* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmergencySetup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 4: {
               if (lastRow == 0) {
                  /* decode bearerCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCapPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 45: {
               if (lastRow <= 1) {
                  /* decode streamId */
                  RTXCTXTPUSHELEMNAME (pctxt, "streamId");

                  ret = NASDec_TS24008IE_StreamIdentifierValue (pctxt, &pvalue
                     ->streamId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.streamIdPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 2) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 46: {
               if (lastRow <= 3) {
                  /* decode emergencyCat */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergencyCat");

                  ret = NASDec_TS24008IE_ServiceCategoryValue (pctxt, &pvalue->
                     emergencyCat);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergencyCatPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_FacilityMsg (OSCTXT* pctxt
   , TS24008Msg_FacilityMsg* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FacilityMsg");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode facility */

   RTXCTXTPUSHELEMNAME (pctxt, "facility");

   ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 127: {
               if (lastRow == 0) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Modify (OSCTXT* pctxt, TS24008Msg_Modify* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Modify");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode bearerCap */

   RTXCTXTPUSHELEMNAME (pctxt, "bearerCap");

   ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->bearerCap);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 124: {
               if (lastRow == 0) {
                  /* decode lowLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "lowLayerComp");

                  ret = NASDec_TS24008IE_LowLayerCompatibility (pctxt, &pvalue
                     ->lowLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lowLayerCompPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 125: {
               if (lastRow <= 1) {
                  /* decode highLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "highLayerComp");

                  ret = NASDec_TS24008IE_HighLayerCompatibility (pctxt, &pvalue
                     ->highLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.highLayerCompPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 163: {
               if (lastRow <= 2) {
                  /* decode revCallSetupDirection */
                  RTXCTXTPUSHELEMNAME (pctxt, "revCallSetupDirection");

                  pvalue->m.revCallSetupDirectionPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 164: {
               if (lastRow <= 3) {
                  /* decode netInitServUpgrdInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "netInitServUpgrdInd");

                  pvalue->m.netInitServUpgrdIndPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyComplete (OSCTXT* pctxt
   , TS24008Msg_ModifyComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyComplete");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode bearerCap */

   RTXCTXTPUSHELEMNAME (pctxt, "bearerCap");

   ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->bearerCap);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 124: {
               if (lastRow == 0) {
                  /* decode lowLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "lowLayerComp");

                  ret = NASDec_TS24008IE_LowLayerCompatibility (pctxt, &pvalue
                     ->lowLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lowLayerCompPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 125: {
               if (lastRow <= 1) {
                  /* decode highLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "highLayerComp");

                  ret = NASDec_TS24008IE_HighLayerCompatibility (pctxt, &pvalue
                     ->highLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.highLayerCompPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 163: {
               if (lastRow <= 2) {
                  /* decode revCallSetupDirection */
                  RTXCTXTPUSHELEMNAME (pctxt, "revCallSetupDirection");

                  pvalue->m.revCallSetupDirectionPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyReject (OSCTXT* pctxt
   , TS24008Msg_ModifyReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode bearerCap */

   RTXCTXTPUSHELEMNAME (pctxt, "bearerCap");

   ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->bearerCap);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 124: {
               if (lastRow == 0) {
                  /* decode lowLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "lowLayerComp");

                  ret = NASDec_TS24008IE_LowLayerCompatibility (pctxt, &pvalue
                     ->lowLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lowLayerCompPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 125: {
               if (lastRow <= 1) {
                  /* decode highLayerComp */
                  RTXCTXTPUSHELEMNAME (pctxt, "highLayerComp");

                  ret = NASDec_TS24008IE_HighLayerCompatibility (pctxt, &pvalue
                     ->highLayerComp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.highLayerCompPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Progress (OSCTXT* pctxt
   , TS24008Msg_Progress* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Progress");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode progressInd */

   RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

   ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->progressInd);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 126: {
               if (lastRow == 0) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_CC_EstablishmentConfirmed (OSCTXT* pctxt
   , TS24008Msg_CC_EstablishmentConfirmed* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CC_EstablishmentConfirmed");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode repeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "repeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     repeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.repeatIndPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 4: {
               if (lastRow <= 1) {
                  /* decode bearerCap1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap1");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap1Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 2) {
                  /* decode bearerCap2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCap2");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCap2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCap2Present = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 8: {
               if (lastRow <= 3) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 4) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Release (OSCTXT* pctxt, TS24008Msg_Release* pvalue
   )
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Release");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 8: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 1) {
                  /* decode secondCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "secondCause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->secondCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.secondCausePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 28: {
               if (lastRow <= 2) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 3) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 4) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Recall (OSCTXT* pctxt, TS24008Msg_Recall* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Recall");

   /* decode recallType */

   RTXCTXTPUSHELEMNAME (pctxt, "recallType");

   ret = NASDec_TS24008IE_RecallType (pctxt, &pvalue->recallType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode facility */

   RTXCTXTPUSHELEMNAME (pctxt, "facility");

   ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, TRUE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ReleaseComplete (OSCTXT* pctxt
   , TS24008Msg_ReleaseComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReleaseComplete");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 8: {
               if (lastRow == 0) {
                  /* decode cause */
                  RTXCTXTPUSHELEMNAME (pctxt, "cause");

                  ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 28: {
               if (lastRow <= 1) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 2) {
                  /* decode user-user */
                  RTXCTXTPUSHELEMNAME (pctxt, "user-user");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->user_user);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.user_userPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 3) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Setup (OSCTXT* pctxt, TS24008Msg_Setup* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Setup");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13 || nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode bcRepeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "bcRepeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     bcRepeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bcRepeatIndPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 12) {
                  /* decode llcRepeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "llcRepeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     llcRepeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.llcRepeatIndPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 15) {
                  /* decode hlcRepeatInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "hlcRepeatInd");

                  ret = NASDec_TS24008IE_RepeatIndicator (pctxt, &pvalue->
                     hlcRepeatInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.hlcRepeatIndPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 4: {
               if (lastRow <= 1) {
                  /* decode bearerCapability1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCapability1");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCapability1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCapability1Present = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 2) {
                  /* decode bearerCapability2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "bearerCapability2");

                  ret = NASDec_TS24008IE_BearerCapability (pctxt, &pvalue->
                     bearerCapability2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.bearerCapability2Present = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 28: {
               if (lastRow <= 3) {
                  /* decode facility */
                  RTXCTXTPUSHELEMNAME (pctxt, "facility");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->facility);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 30: {
               if (lastRow <= 4) {
                  /* decode progressInd */
                  RTXCTXTPUSHELEMNAME (pctxt, "progressInd");

                  ret = NASDec_TS24008IE_ProgressIndicator (pctxt, &pvalue->
                     progressInd);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.progressIndPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 5) {
                  /* decode signal */
                  RTXCTXTPUSHELEMNAME (pctxt, "signal");

                  ret = NASDec_TS24008IE_Signal (pctxt, &pvalue->signal_);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.signal_Present = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 92: {
               if (lastRow <= 6) {
                  /* decode callingPartyNumber */
                  RTXCTXTPUSHELEMNAME (pctxt, "callingPartyNumber");

                  ret = NASDec_TS24008IE_CallingPartyBCDNumber (pctxt, &pvalue
                     ->callingPartyNumber);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.callingPartyNumberPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 93: {
               if (lastRow <= 7) {
                  /* decode callingPartySubaddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "callingPartySubaddress");

                  ret = NASDec_TS24008IE_PartySubaddress (pctxt, &pvalue->
                     callingPartySubaddress);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.callingPartySubaddressPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 94: {
               if (lastRow <= 8) {
                  /* decode calledPartyNumber */
                  RTXCTXTPUSHELEMNAME (pctxt, "calledPartyNumber");

                  ret = NASDec_TS24008IE_CalledPartyBCDNumber (pctxt, &pvalue->
                     calledPartyNumber);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.calledPartyNumberPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 109: {
               if (lastRow <= 9) {
                  /* decode calledPartySubaddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "calledPartySubaddress");

                  ret = NASDec_TS24008IE_PartySubaddress (pctxt, &pvalue->
                     calledPartySubaddress);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.calledPartySubaddressPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 116: {
               if (lastRow <= 10) {
                  /* decode redirectingPartyNumber */
                  RTXCTXTPUSHELEMNAME (pctxt, "redirectingPartyNumber");

                  ret = NASDec_TS24008IE_RedirectingPartyBCDNumber (pctxt, &
                     pvalue->redirectingPartyNumber);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.redirectingPartyNumberPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 117: {
               if (lastRow <= 11) {
                  /* decode redirectingPartySubaddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "redirectingPartySubaddress");

                  ret = NASDec_TS24008IE_PartySubaddress (pctxt, &pvalue->
                     redirectingPartySubaddress);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.redirectingPartySubaddressPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 124: {
               if (lastRow <= 13) {
                  /* decode lowLayerCompat1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "lowLayerCompat1");

                  ret = NASDec_TS24008IE_LowLayerCompatibility (pctxt, &pvalue
                     ->lowLayerCompat1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lowLayerCompat1Present = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 14) {
                  /* decode lowLayerCompat2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "lowLayerCompat2");

                  ret = NASDec_TS24008IE_LowLayerCompatibility (pctxt, &pvalue
                     ->lowLayerCompat2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lowLayerCompat2Present = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 125: {
               if (lastRow <= 16) {
                  /* decode highLayerCompat1 */
                  RTXCTXTPUSHELEMNAME (pctxt, "highLayerCompat1");

                  ret = NASDec_TS24008IE_HighLayerCompatibility (pctxt, &pvalue
                     ->highLayerCompat1);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.highLayerCompat1Present = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else if (lastRow <= 17) {
                  /* decode highLayerCompat2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "highLayerCompat2");

                  ret = NASDec_TS24008IE_HighLayerCompatibility (pctxt, &pvalue
                     ->highLayerCompat2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.highLayerCompat2Present = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 126: {
               if (lastRow <= 18) {
                  /* decode userUser */
                  RTXCTXTPUSHELEMNAME (pctxt, "userUser");

                  ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->userUser);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.userUserPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 8: {
               if (lastRow <= 19) {
                  /* decode priorityLevel */
                  RTXCTXTPUSHELEMNAME (pctxt, "priorityLevel");

                  ret = NASDec_TS24008IE_PriorityLevel (pctxt, &pvalue->
                     priorityLevel);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.priorityLevelPresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 25: {
               if (lastRow <= 20) {
                  /* decode alertingPattern */
                  RTXCTXTPUSHELEMNAME (pctxt, "alertingPattern");

                  ret = NASDec_TS24008IE_AlertingPattern (pctxt, &pvalue->
                     alertingPattern);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.alertingPatternPresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 47: {
               if (lastRow <= 21) {
                  /* decode netCallCtrlCaps */
                  RTXCTXTPUSHELEMNAME (pctxt, "netCallCtrlCaps");

                  ret = NASDec_TS24008IE_NetCallCtrlCaps (pctxt, &pvalue->
                     netCallCtrlCaps);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netCallCtrlCapsPresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 58: {
               if (lastRow <= 22) {
                  /* decode causeOfNoCLI */
                  RTXCTXTPUSHELEMNAME (pctxt, "causeOfNoCLI");

                  ret = NASDec_TS24008IE_CauseOfNoCLI (pctxt, &pvalue->
                     causeOfNoCLI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.causeOfNoCLIPresent = 1;

                  lastRow = 23;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 65: {
               if (lastRow <= 23) {
                  /* decode backupBearerCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "backupBearerCapability");

                  ret = NASDec_TS24008IE_BackupBearerCapability (pctxt, &pvalue
                     ->backupBearerCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.backupBearerCapabilityPresent = 1;

                  lastRow = 24;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 127: {
               if (lastRow <= 24) {
                  /* decode ssVersion */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssVersion");

                  ret = NASDec_TS24008IE_SSVersionIndicator (pctxt, &pvalue->
                     ssVersion);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssVersionPresent = 1;

                  lastRow = 25;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 161: {
               if (lastRow <= 25) {
                  /* decode clirSuppression */
                  RTXCTXTPUSHELEMNAME (pctxt, "clirSuppression");

                  pvalue->m.clirSuppressionPresent = 1;

                  lastRow = 26;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 162: {
               if (lastRow <= 26) {
                  /* decode clirInvocation */
                  RTXCTXTPUSHELEMNAME (pctxt, "clirInvocation");

                  pvalue->m.clirInvocationPresent = 1;

                  lastRow = 27;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 21: {
               if (lastRow <= 27) {
                  /* decode callCtrlCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "callCtrlCap");

                  ret = NASDec_TS24008IE_CallControlCapabilities (pctxt, &
                     pvalue->callCtrlCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.callCtrlCapPresent = 1;

                  lastRow = 28;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 29: {
               if (lastRow <= 28) {
                  /* decode facilityAdvRecallAlign */
                  RTXCTXTPUSHELEMNAME (pctxt, "facilityAdvRecallAlign");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->
                     facilityAdvRecallAlign);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityAdvRecallAlignPresent = 1;

                  lastRow = 29;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 27: {
               if (lastRow <= 29) {
                  /* decode facilityRecallAlignNotEssential */
                  RTXCTXTPUSHELEMNAME (pctxt, "facilityRecallAlignNotEssential");

                  ret = NASDec_TS24008IE_Facility (pctxt, &pvalue->
                     facilityRecallAlignNotEssential);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.facilityRecallAlignNotEssentialPresent = 1;

                  lastRow = 30;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 45: {
               if (lastRow <= 30) {
                  /* decode streamId */
                  RTXCTXTPUSHELEMNAME (pctxt, "streamId");

                  ret = NASDec_TS24008IE_StreamIdentifierValue (pctxt, &pvalue
                     ->streamId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.streamIdPresent = 1;

                  lastRow = 31;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 31) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 32;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 163: {
               if (lastRow <= 32) {
                  /* decode redial */
                  RTXCTXTPUSHELEMNAME (pctxt, "redial");

                  pvalue->m.redialPresent = 1;

                  lastRow = 33;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_StartCC (OSCTXT* pctxt, TS24008Msg_StartCC* pvalue
   )
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "StartCC");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 33: {
               if (lastRow == 0) {
                  /* decode ccCapabilities */
                  RTXCTXTPUSHELEMNAME (pctxt, "ccCapabilities");

                  ret = NASDec_TS24008IE_CallControlCapabilities (pctxt, &
                     pvalue->ccCapabilities);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ccCapabilitiesPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_Status (OSCTXT* pctxt, TS24008Msg_Status* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Status");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24008IE_Cause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode callState */

   RTXCTXTPUSHELEMNAME (pctxt, "callState");

   ret = NASDec_TS24008IE_CallState (pctxt, &pvalue->callState);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 36: {
               if (lastRow == 0) {
                  /* decode auxStates */
                  RTXCTXTPUSHELEMNAME (pctxt, "auxStates");

                  ret = NASDec_TS24008IE_AuxiliaryStates (pctxt, &pvalue->
                     auxStates);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.auxStatesPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_UserInfo (OSCTXT* pctxt
   , TS24008Msg_UserInfo* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UserInfo");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode userUser */

   RTXCTXTPUSHELEMNAME (pctxt, "userUser");

   ret = NASDec_TS24008IE_UserUser (pctxt, &pvalue->userUser);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 160: {
               if (lastRow == 0) {
                  /* decode moreData */
                  RTXCTXTPUSHELEMNAME (pctxt, "moreData");

                  pvalue->m.moreDataPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 183;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AttachRequest (OSCTXT* pctxt
   , TS24008Msg_AttachRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode msNetCapability */

   RTXCTXTPUSHELEMNAME (pctxt, "msNetCapability");

   ret = NASDec_TS24008IE_MSNetworkCapability (pctxt, &pvalue->msNetCapability
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gprsCiphKeySeq */

   RTXCTXTPUSHELEMNAME (pctxt, "gprsCiphKeySeq");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->gprsCiphKeySeq);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode attachType */

   RTXCTXTPUSHELEMNAME (pctxt, "attachType");

   ret = NASDec_TS24008IE_AttachType (pctxt, &pvalue->attachType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode drxParameter */

   RTXCTXTPUSHELEMNAME (pctxt, "drxParameter");

   ret = NASDec_TS24008IE_DRXParameter (pctxt, &pvalue->drxParameter);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pTMSIOrIMSI */

   RTXCTXTPUSHELEMNAME (pctxt, "pTMSIOrIMSI");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->pTMSIOrIMSI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode oldRoutingAreaId */

   RTXCTXTPUSHELEMNAME (pctxt, "oldRoutingAreaId");

   ret = NASDec_TS24008IE_RoutingAreaIdent (pctxt, &pvalue->oldRoutingAreaId);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msRACapability */

   RTXCTXTPUSHELEMNAME (pctxt, "msRACapability");

   ret = NASDec_TS24008IE_MSRadioAccessCapability (pctxt, &pvalue->
      msRACapability);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 9 || nibble == 13 || nibble == 14 || nibble == 12 || nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode oldPTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldPTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     oldPTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldPTMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 23: {
               if (lastRow <= 1) {
                  /* decode reqREADYTimerValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqREADYTimerValue");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->
                     reqREADYTimerValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqREADYTimerValuePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 9: {
               if (lastRow <= 2) {
                  /* decode tmsiStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiStatus");

                  ret = NASDec_TS24008IE_TMSIStatus (pctxt, &pvalue->tmsiStatus
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiStatusPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 51: {
               if (lastRow <= 3) {
                  /* decode psLCSCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "psLCSCap");

                  ret = NASDec_TS24008IE_PS_LCSCapbility (pctxt, &pvalue->
                     psLCSCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.psLCSCapPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 17: {
               if (lastRow <= 4) {
                  /* decode msClassmark2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "msClassmark2");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->msClassmark2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msClassmark2Present = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 32: {
               if (lastRow <= 5) {
                  /* decode msClassmark3 */
                  RTXCTXTPUSHELEMNAME (pctxt, "msClassmark3");

                  ret = NASDec_TS24008IE_MobileStationClassmark3 (pctxt, &
                     pvalue->msClassmark3);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msClassmark3Present = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 6) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 80: {
               if (lastRow <= 7) {
                  /* decode ueNetCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueNetCap");

                  ret = NASDec_TS24008IE_UENetCapability (pctxt, &pvalue->
                     ueNetCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueNetCapPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 26: {
               if (lastRow <= 8) {
                  /* decode addnMobileId */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnMobileId");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     addnMobileId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnMobileIdPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 27: {
               if (lastRow <= 9) {
                  /* decode addnOldRoutingAreaId */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnOldRoutingAreaId");

                  ret = NASDec_TS24008IE_RoutingAreaIdent2 (pctxt, &pvalue->
                     addnOldRoutingAreaId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnOldRoutingAreaIdPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 93: {
               if (lastRow <= 10) {
                  /* decode voiceDomainPref */
                  RTXCTXTPUSHELEMNAME (pctxt, "voiceDomainPref");

                  ret = NASDec_TS24008IE_VoiceDomainPref (pctxt, &pvalue->
                     voiceDomainPref);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.voiceDomainPrefPresent = 1;
                  pvalue->m._v9ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 13: {
               if (lastRow <= 11) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 14: {
               if (lastRow <= 12) {
                  /* decode p-TMSI-Type */
                  RTXCTXTPUSHELEMNAME (pctxt, "p-TMSI-Type");

                  ret = NASDec_TS24008IE_P_TMSI_Type (pctxt, &pvalue->
                     p_TMSI_Type);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.p_TMSI_TypePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 13) {
                  /* decode msNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetFeatureSupport");

                  ret = NASDec_TS24008IE_MSNetFeatureSupport (pctxt, &pvalue->
                     msNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetFeatureSupportPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 20: {
               if (lastRow <= 14) {
                  /* decode oldLocAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldLocAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent2 (pctxt, &pvalue->
                     oldLocAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldLocAreaIdentPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 15) {
                  /* decode addnUpdateType */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateType");

                  ret = NASDec_TS24008IE_AddnUpdateType (pctxt, &pvalue->
                     addnUpdateType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateTypePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 16: {
               if (lastRow <= 16) {
                  /* decode tmsiBasedNRICont */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiBasedNRICont");

                  ret = NASDec_TS24008IE_NetResourceIdentContainer (pctxt, &
                     pvalue->tmsiBasedNRICont);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiBasedNRIContPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AttachAccept (OSCTXT* pctxt
   , TS24008Msg_AttachAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode attachResult */

   RTXCTXTPUSHELEMNAME (pctxt, "attachResult");

   ret = NASDec_TS24008IE_AttachResult (pctxt, &pvalue->attachResult);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode periodicRAUpdateTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "periodicRAUpdateTimer");

   ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->periodicRAUpdateTimer);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioPriForTOM8 */

   RTXCTXTPUSHELEMNAME (pctxt, "radioPriForTOM8");

   ret = NASDec_TS24008IE_RadioPriorityValue2 (pctxt, &pvalue->radioPriForTOM8
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioPriForSMS */

   RTXCTXTPUSHELEMNAME (pctxt, "radioPriForSMS");

   ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->radioPriForSMS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode routingAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "routingAreaIdent");

   ret = NASDec_TS24008IE_RoutingAreaIdent (pctxt, &pvalue->routingAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11 || nibble == 10) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode pTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     pTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 23: {
               if (lastRow <= 1) {
                  /* decode negotiatedREADYTimerValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedREADYTimerValue");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->
                     negotiatedREADYTimerValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedREADYTimerValuePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 24: {
               if (lastRow <= 2) {
                  /* decode allocatedPTMSI */
                  RTXCTXTPUSHELEMNAME (pctxt, "allocatedPTMSI");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     allocatedPTMSI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allocatedPTMSIPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 35: {
               if (lastRow <= 3) {
                  /* decode msIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "msIdentity");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     msIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msIdentityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 37: {
               if (lastRow <= 4) {
                  /* decode gmmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

                  ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->
                     gmmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gmmCausePresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 42: {
               if (lastRow <= 5) {
                  /* decode t3302Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3302Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3302Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3302ValuePresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 140: {
               if (lastRow <= 6) {
                  /* decode cellNotification */
                  RTXCTXTPUSHELEMNAME (pctxt, "cellNotification");

                  pvalue->m.cellNotificationPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 74: {
               if (lastRow <= 7) {
                  /* decode equivalentPLMNs */
                  RTXCTXTPUSHELEMNAME (pctxt, "equivalentPLMNs");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->
                     equivalentPLMNs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.equivalentPLMNsPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 11: {
               if (lastRow <= 8) {
                  /* decode netFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "netFeatureSupport");

                  ret = NASDec_TS24008IE_NetFeatureSupp (pctxt, &pvalue->
                     netFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netFeatureSupportPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 9) {
                  /* decode emergencyNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergencyNumList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergencyNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergencyNumListPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 10) {
                  /* decode requestedMSInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestedMSInfo");

                  ret = NASDec_TS24008IE_RequestedMSInfo (pctxt, &pvalue->
                     requestedMSInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestedMSInfoPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 55: {
               if (lastRow <= 11) {
                  /* decode t3319Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3319Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3319Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3319ValuePresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 56: {
               if (lastRow <= 12) {
                  /* decode t3323Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3323Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3323Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3323ValuePresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 57: {
               if (lastRow <= 13) {
                  /* decode t3312Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3312Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3312Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3312ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 102: {
               if (lastRow <= 14) {
                  /* decode addnNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnNetFeatureSupport");

                  ret = NASDec_TS24008IE_AddnNetFeatureSupport (pctxt, &pvalue
                     ->addnNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnNetFeatureSupportPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AttachComplete (OSCTXT* pctxt
   , TS24008Msg_AttachComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachComplete");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode erRATInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "erRATInfoContainer");

                  ret = NASDec_TS24008IE_InterRATInfoContainer (pctxt, &pvalue
                     ->erRATInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.erRATInfoContainerPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 43: {
               if (lastRow <= 1) {
                  /* decode eUTRANInterRATInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "eUTRANInterRATInfoContainer");

                  ret = NASDec_TS24008IE_E_UTRANInterRATInfoContainer (pctxt, &
                     pvalue->eUTRANInterRATInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eUTRANInterRATInfoContainerPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AttachReject (OSCTXT* pctxt
   , TS24008Msg_AttachReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode gmmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

   ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->gmmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 42: {
               if (lastRow == 0) {
                  /* decode t3302Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3302Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3302Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3302ValuePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 58: {
               if (lastRow <= 1) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_DetachRequest (OSCTXT* pctxt
   , TS24008Msg_DetachRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DetachRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode detachType */

   RTXCTXTPUSHELEMNAME (pctxt, "detachType");

   ret = NASDec_TS24008IE_DetachType (pctxt, &pvalue->detachType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 37: {
               if (lastRow == 0) {
                  /* decode gmmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

                  ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->
                     gmmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gmmCausePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 24: {
               if (lastRow <= 1) {
                  /* decode pTMSI */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSI");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->pTMSI
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSIPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 25: {
               if (lastRow <= 2) {
                  /* decode pTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature2 (pctxt, &pvalue->
                     pTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSISignaturePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

/* begin custom source file TS24008MsgDec_DetachAccept.c */

/* Custom decode function (TS24008MsgDec_DetachAccept.c) */

EXTERN int NASDec_TS24008Msg_DetachAccept (OSCTXT* pctxt
   , TS24008Msg_DetachAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DetachAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* The OS3GMOBORIG flag is checked in the context to determine if 
      this is a mobile-originated message.  The user must set this 
      explicitly before calling the decode PDU function. */

   if (rtxCtxtTestFlag (pctxt, OS3GMOBORIG)) {
      /* 3G originated, forceToStandby flag should be present */
      RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

      /* skip spare bits */
      ret = rtxSkipBits (pctxt, 4);
      if (ret < 0) return LOG_RTERR (pctxt, ret);

      /* decode IE value */
      ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->
         forceToStandby);
      if (ret < 0) return LOG_RTERR (pctxt, ret);

      pvalue->m.forceToStandbyPresent = 1;

      RTXCTXTPOPELEMNAME (pctxt);
   }

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

/* end custom source file TS24008MsgDec_DetachAccept.c */

EXTERN int NASDec_TS24008Msg_P_TMSIReallocCmd (OSCTXT* pctxt
   , TS24008Msg_P_TMSIReallocCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "P_TMSIReallocCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode allocatedPTMSI */

   RTXCTXTPUSHELEMNAME (pctxt, "allocatedPTMSI");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->allocatedPTMSI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode routingAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "routingAreaIdent");

   ret = NASDec_TS24008IE_RoutingAreaIdent (pctxt, &pvalue->routingAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode pTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     pTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthAndCiphRequest (OSCTXT* pctxt
   , TS24008Msg_AuthAndCiphRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthAndCiphRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cipheringAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "cipheringAlgorithm");

   ret = NASDec_TS24008IE_CipheringAlgorithmType (pctxt, &pvalue->
      cipheringAlgorithm);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode imeisvRequest */

   RTXCTXTPUSHELEMNAME (pctxt, "imeisvRequest");

   ret = NASDec_TS24008IE_IMEISVRequest (pctxt, &pvalue->imeisvRequest);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode acRefNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "acRefNumber");

   ret = NASDec_TS24008IE_AC_Reference_Number (pctxt, &pvalue->acRefNumber);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 33: {
               if (lastRow == 0) {
                  /* decode authParamRAND */
                  RTXCTXTPUSHELEMNAME (pctxt, "authParamRAND");

                  ret = NASDec_TS24008IE_AuthParamRAND (pctxt, &pvalue->
                     authParamRAND);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authParamRANDPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 16;
               }
               break;
            }
            case 8: {
               if (lastRow <= 1) {
                  /* decode ciphKeySeqNum */
                  RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

                  ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->
                     ciphKeySeqNum);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ciphKeySeqNumPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 40: {
               if (lastRow <= 2) {
                  /* decode authParamAUTN */
                  RTXCTXTPUSHELEMNAME (pctxt, "authParamAUTN");

                  ret = NASDec_TS24008IE_AuthParamAUTN (pctxt, &pvalue->
                     authParamAUTN);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authParamAUTNPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthAndCiphResponse (OSCTXT* pctxt
   , TS24008Msg_AuthAndCiphResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthAndCiphResponse");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode acRefNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "acRefNumber");

   ret = NASDec_TS24008IE_AC_Reference_Number (pctxt, &pvalue->acRefNumber);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 34: {
               if (lastRow == 0) {
                  /* decode authRespParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "authRespParam");

                  ret = NASDec_TS24008IE_AuthRespParam (pctxt, &pvalue->
                     authRespParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authRespParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 4;
               }
               break;
            }
            case 35: {
               if (lastRow <= 1) {
                  /* decode imeisv */
                  RTXCTXTPUSHELEMNAME (pctxt, "imeisv");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->imeisv
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.imeisvPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 41: {
               if (lastRow <= 2) {
                  /* decode authRespParamExt */
                  RTXCTXTPUSHELEMNAME (pctxt, "authRespParamExt");

                  ret = NASDec_TS24008IE_AuthRespParamExt (pctxt, &pvalue->
                     authRespParamExt);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authRespParamExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_AuthAndCiphFailure (OSCTXT* pctxt
   , TS24008Msg_AuthAndCiphFailure* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthAndCiphFailure");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode gmmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

   ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->gmmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 48: {
               if (lastRow == 0) {
                  /* decode authFailureParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "authFailureParam");

                  ret = NASDec_TS24008IE_AuthFailureParam (pctxt, &pvalue->
                     authFailureParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authFailureParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_GMMIdentityRequest (OSCTXT* pctxt
   , TS24008Msg_GMMIdentityRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GMMIdentityRequest");

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode identityType */

   RTXCTXTPUSHELEMNAME (pctxt, "identityType");

   ret = NASDec_TS24008IE_IdentityType2Value (pctxt, &pvalue->identityType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_GMMIdentityResponse (OSCTXT* pctxt
   , TS24008Msg_GMMIdentityResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GMMIdentityResponse");

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RoutingAreaUpdateRequest (OSCTXT* pctxt
   , TS24008Msg_RoutingAreaUpdateRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoutingAreaUpdateRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode gprsCiphKeySeq */

   RTXCTXTPUSHELEMNAME (pctxt, "gprsCiphKeySeq");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->gprsCiphKeySeq);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode updateType */

   RTXCTXTPUSHELEMNAME (pctxt, "updateType");

   ret = NASDec_TS24008IE_UpdateType (pctxt, &pvalue->updateType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode oldRoutingAreaId */

   RTXCTXTPUSHELEMNAME (pctxt, "oldRoutingAreaId");

   ret = NASDec_TS24008IE_RoutingAreaIdent (pctxt, &pvalue->oldRoutingAreaId);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msRACapability */

   RTXCTXTPUSHELEMNAME (pctxt, "msRACapability");

   ret = NASDec_TS24008IE_MSRadioAccessCapability (pctxt, &pvalue->
      msRACapability);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 9 || nibble == 14 || nibble == 13 || nibble == 12 || nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode oldPTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldPTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     oldPTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldPTMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 23: {
               if (lastRow <= 1) {
                  /* decode reqREADYTimerValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqREADYTimerValue");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->
                     reqREADYTimerValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqREADYTimerValuePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 39: {
               if (lastRow <= 2) {
                  /* decode drxParameter */
                  RTXCTXTPUSHELEMNAME (pctxt, "drxParameter");

                  ret = NASDec_TS24008IE_DRXParameter (pctxt, &pvalue->
                     drxParameter);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.drxParameterPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 9: {
               if (lastRow <= 3) {
                  /* decode tmsiStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiStatus");

                  ret = NASDec_TS24008IE_TMSIStatus (pctxt, &pvalue->tmsiStatus
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiStatusPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 24: {
               if (lastRow <= 4) {
                  /* decode pTMSI */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSI");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->pTMSI
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSIPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 49: {
               if (lastRow <= 5) {
                  /* decode msNetCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetCapability");

                  ret = NASDec_TS24008IE_MSNetworkCapability (pctxt, &pvalue->
                     msNetCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetCapabilityPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 6) {
                  /* decode pdpContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpContextStatus");

                  ret = NASDec_TS24008IE_PDPContextStatus (pctxt, &pvalue->
                     pdpContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpContextStatusPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 51: {
               if (lastRow <= 7) {
                  /* decode psLCSCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "psLCSCap");

                  ret = NASDec_TS24008IE_PS_LCSCapbility (pctxt, &pvalue->
                     psLCSCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.psLCSCapPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 8) {
                  /* decode mbmsContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsContextStatus");

                  ret = NASDec_TS24008IE_MBMSContextStatus (pctxt, &pvalue->
                     mbmsContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsContextStatusPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 88: {
               if (lastRow <= 9) {
                  /* decode ueNetCap */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueNetCap");

                  ret = NASDec_TS24008IE_UENetCapability (pctxt, &pvalue->
                     ueNetCap);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueNetCapPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 26: {
               if (lastRow <= 10) {
                  /* decode addnMobileId */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnMobileId");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     addnMobileId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnMobileIdPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 27: {
               if (lastRow <= 11) {
                  /* decode addnOldRoutingAreaId */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnOldRoutingAreaId");

                  ret = NASDec_TS24008IE_RoutingAreaIdent2 (pctxt, &pvalue->
                     addnOldRoutingAreaId);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnOldRoutingAreaIdPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 17: {
               if (lastRow <= 12) {
                  /* decode msClassmark2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "msClassmark2");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->msClassmark2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msClassmark2Present = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 32: {
               if (lastRow <= 13) {
                  /* decode msClassmark3 */
                  RTXCTXTPUSHELEMNAME (pctxt, "msClassmark3");

                  ret = NASDec_TS24008IE_MobileStationClassmark3 (pctxt, &
                     pvalue->msClassmark3);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msClassmark3Present = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 14) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 93: {
               if (lastRow <= 15) {
                  /* decode voiceDomainPref */
                  RTXCTXTPUSHELEMNAME (pctxt, "voiceDomainPref");

                  ret = NASDec_TS24008IE_VoiceDomainPref (pctxt, &pvalue->
                     voiceDomainPref);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.voiceDomainPrefPresent = 1;
                  pvalue->m._v9ExtPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 14: {
               if (lastRow <= 16) {
                  /* decode p-TMSI-Type */
                  RTXCTXTPUSHELEMNAME (pctxt, "p-TMSI-Type");

                  ret = NASDec_TS24008IE_P_TMSI_Type (pctxt, &pvalue->
                     p_TMSI_Type);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.p_TMSI_TypePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 17) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 18) {
                  /* decode msNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetFeatureSupport");

                  ret = NASDec_TS24008IE_MSNetFeatureSupport (pctxt, &pvalue->
                     msNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetFeatureSupportPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 20: {
               if (lastRow <= 19) {
                  /* decode oldLocAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldLocAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent2 (pctxt, &pvalue->
                     oldLocAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldLocAreaIdentPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 20) {
                  /* decode addnUpdateType */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateType");

                  ret = NASDec_TS24008IE_AddnUpdateType (pctxt, &pvalue->
                     addnUpdateType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateTypePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 16: {
               if (lastRow <= 21) {
                  /* decode tmsiBasedNRICont */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiBasedNRICont");

                  ret = NASDec_TS24008IE_NetResourceIdentContainer (pctxt, &
                     pvalue->tmsiBasedNRICont);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiBasedNRIContPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RoutingAreaUpdateAccept (OSCTXT* pctxt
   , TS24008Msg_RoutingAreaUpdateAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoutingAreaUpdateAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode updateResult */

   RTXCTXTPUSHELEMNAME (pctxt, "updateResult");

   ret = NASDec_TS24008IE_UpdateResult (pctxt, &pvalue->updateResult);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode periodicRAUpdateTimer */

   RTXCTXTPUSHELEMNAME (pctxt, "periodicRAUpdateTimer");

   ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->periodicRAUpdateTimer);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode routingAreaIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "routingAreaIdent");

   ret = NASDec_TS24008IE_RoutingAreaIdent (pctxt, &pvalue->routingAreaIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11 || nibble == 10) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode pTMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "pTMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     pTMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pTMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 24: {
               if (lastRow <= 1) {
                  /* decode allocatedPTMSI */
                  RTXCTXTPUSHELEMNAME (pctxt, "allocatedPTMSI");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     allocatedPTMSI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.allocatedPTMSIPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 35: {
               if (lastRow <= 2) {
                  /* decode msIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "msIdentity");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     msIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msIdentityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 38: {
               if (lastRow <= 3) {
                  /* decode receiveNPDUNumberList */
                  RTXCTXTPUSHELEMNAME (pctxt, "receiveNPDUNumberList");

                  ret = NASDec_TS24008IE_ReceiveNPDUNumberList (pctxt, &pvalue
                     ->receiveNPDUNumberList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.receiveNPDUNumberListPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 23: {
               if (lastRow <= 4) {
                  /* decode negotiatedREADYTimerValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedREADYTimerValue");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->
                     negotiatedREADYTimerValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedREADYTimerValuePresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 37: {
               if (lastRow <= 5) {
                  /* decode gmmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

                  ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->
                     gmmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gmmCausePresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 42: {
               if (lastRow <= 6) {
                  /* decode t3302Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3302Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3302Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3302ValuePresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 140: {
               if (lastRow <= 7) {
                  /* decode cellNotification */
                  RTXCTXTPUSHELEMNAME (pctxt, "cellNotification");

                  pvalue->m.cellNotificationPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 74: {
               if (lastRow <= 8) {
                  /* decode equivalentPLMNs */
                  RTXCTXTPUSHELEMNAME (pctxt, "equivalentPLMNs");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->
                     equivalentPLMNs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.equivalentPLMNsPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 9) {
                  /* decode pdpContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpContextStatus");

                  ret = NASDec_TS24008IE_PDPContextStatus (pctxt, &pvalue->
                     pdpContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpContextStatusPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 11: {
               if (lastRow <= 10) {
                  /* decode netFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "netFeatureSupport");

                  ret = NASDec_TS24008IE_NetFeatureSupp (pctxt, &pvalue->
                     netFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.netFeatureSupportPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 11) {
                  /* decode emergencyNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergencyNumList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergencyNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergencyNumListPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 12) {
                  /* decode mbmsContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsContextStatus");

                  ret = NASDec_TS24008IE_MBMSContextStatus (pctxt, &pvalue->
                     mbmsContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsContextStatusPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 13) {
                  /* decode requestedMSInfo */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestedMSInfo");

                  ret = NASDec_TS24008IE_RequestedMSInfo (pctxt, &pvalue->
                     requestedMSInfo);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestedMSInfoPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 55: {
               if (lastRow <= 14) {
                  /* decode t3319Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3319Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3319Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3319ValuePresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 56: {
               if (lastRow <= 15) {
                  /* decode t3323Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3323Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3323Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3323ValuePresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 57: {
               if (lastRow <= 16) {
                  /* decode t3312Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3312Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3312Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3312ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 102: {
               if (lastRow <= 17) {
                  /* decode addnNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnNetFeatureSupport");

                  ret = NASDec_TS24008IE_AddnNetFeatureSupport (pctxt, &pvalue
                     ->addnNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnNetFeatureSupportPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RoutingAreaUpdateComplete (OSCTXT* pctxt
   , TS24008Msg_RoutingAreaUpdateComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoutingAreaUpdateComplete");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 38: {
               if (lastRow == 0) {
                  /* decode receiveNPDUNumberList */
                  RTXCTXTPUSHELEMNAME (pctxt, "receiveNPDUNumberList");

                  ret = NASDec_TS24008IE_ReceiveNPDUNumberList (pctxt, &pvalue
                     ->receiveNPDUNumberList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.receiveNPDUNumberListPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode interRATInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "interRATInfoContainer");

                  ret = NASDec_TS24008IE_InterRATInfoContainer (pctxt, &pvalue
                     ->interRATInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.interRATInfoContainerPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 43: {
               if (lastRow <= 2) {
                  /* decode eUTRANInterRATInfoContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "eUTRANInterRATInfoContainer");

                  ret = NASDec_TS24008IE_E_UTRANInterRATInfoContainer (pctxt, &
                     pvalue->eUTRANInterRATInfoContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.eUTRANInterRATInfoContainerPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RoutingAreaUpdateReject (OSCTXT* pctxt
   , TS24008Msg_RoutingAreaUpdateReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoutingAreaUpdateReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode gmmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

   ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->gmmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode forceToStandby */

   RTXCTXTPUSHELEMNAME (pctxt, "forceToStandby");

   ret = NASDec_TS24008IE_ForceToStandbyValue (pctxt, &pvalue->forceToStandby
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 42: {
               if (lastRow == 0) {
                  /* decode gprsTimer2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "gprsTimer2");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->gprsTimer2
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gprsTimer2Present = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 58: {
               if (lastRow <= 1) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_GMMInformation (OSCTXT* pctxt
   , TS24008Msg_GMMInformation* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GMMInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 67: {
               if (lastRow == 0) {
                  /* decode fullNetName */
                  RTXCTXTPUSHELEMNAME (pctxt, "fullNetName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     fullNetName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.fullNetNamePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 69: {
               if (lastRow <= 1) {
                  /* decode shortNetName */
                  RTXCTXTPUSHELEMNAME (pctxt, "shortNetName");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     shortNetName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.shortNetNamePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 70: {
               if (lastRow <= 2) {
                  /* decode localTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "localTimeZone");

                  ret = NASDec_TS24008IE_TimeZone (pctxt, &pvalue->
                     localTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.localTimeZonePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 71: {
               if (lastRow <= 3) {
                  /* decode universalAndLocalTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "universalAndLocalTimeZone");

                  ret = NASDec_TS24008IE_TimeZoneAndTime (pctxt, &pvalue->
                     universalAndLocalTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.universalAndLocalTimeZonePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 7;
               }
               break;
            }
            case 72: {
               if (lastRow <= 4) {
                  /* decode lsaIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "lsaIdentity");

                  ret = NASDec_TS24008IE_LSAIdentifier (pctxt, &pvalue->
                     lsaIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lsaIdentityPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 73: {
               if (lastRow <= 5) {
                  /* decode networkDST */
                  RTXCTXTPUSHELEMNAME (pctxt, "networkDST");

                  ret = NASDec_TS24008IE_DaylightSavingTime (pctxt, &pvalue->
                     networkDST);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.networkDSTPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ServiceRequest (OSCTXT* pctxt
   , TS24008Msg_ServiceRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode serviceType */

   RTXCTXTPUSHELEMNAME (pctxt, "serviceType");

   ret = NASDec_TS24008IE_ServiceType (pctxt, &pvalue->serviceType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ciphKeySeqNum */

   RTXCTXTPUSHELEMNAME (pctxt, "ciphKeySeqNum");

   ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->ciphKeySeqNum);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode mobileIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "mobileIdentity");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->mobileIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 50: {
               if (lastRow == 0) {
                  /* decode pdpContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpContextStatus");

                  ret = NASDec_TS24008IE_PDPContextStatus (pctxt, &pvalue->
                     pdpContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpContextStatusPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 1) {
                  /* decode mbmsContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsContextStatus");

                  ret = NASDec_TS24008IE_MBMSContextStatus (pctxt, &pvalue->
                     mbmsContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsContextStatusPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 54: {
               if (lastRow <= 2) {
                  /* decode uplinkDataStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "uplinkDataStatus");

                  ret = NASDec_TS24008IE_UplinkDataStatus (pctxt, &pvalue->
                     uplinkDataStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.uplinkDataStatusPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 13: {
               if (lastRow <= 3) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ServiceAccept (OSCTXT* pctxt
   , TS24008Msg_ServiceAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 50: {
               if (lastRow == 0) {
                  /* decode pdpContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpContextStatus");

                  ret = NASDec_TS24008IE_PDPContextStatus (pctxt, &pvalue->
                     pdpContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpContextStatusPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 1) {
                  /* decode mbmsContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsContextStatus");

                  ret = NASDec_TS24008IE_MBMSContextStatus (pctxt, &pvalue->
                     mbmsContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsContextStatusPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ServiceReject (OSCTXT* pctxt
   , TS24008Msg_ServiceReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode gmmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "gmmCause");

   ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->gmmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 58: {
               if (lastRow == 0) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivatePDPCtxtReq (OSCTXT* pctxt
   , TS24008Msg_ActivatePDPCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivatePDPCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode requestedNSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedNSAPI");

   ret = NASDec_TS24008IE_NSAPIValue (pctxt, &pvalue->requestedNSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->requestedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->requestedQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedPDPAddr */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedPDPAddr");

   ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->requestedPDPAddr
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 10 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 40: {
               if (lastRow == 0) {
                  /* decode accessPointName */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

                  ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->
                     accessPointName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessPointNamePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 10: {
               if (lastRow <= 2) {
                  /* decode requestType */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestType");

                  ret = NASDec_TS24008IE_RequestTypeValue (pctxt, &pvalue->
                     requestType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestTypePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 3) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivatePDPCtxtAccept (OSCTXT* pctxt
   , TS24008Msg_ActivatePDPCtxtAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivatePDPCtxtAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode negotiatedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->negotiatedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode negotiatedQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "negotiatedQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->negotiatedQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

   ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->radioPriority);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 43: {
               if (lastRow == 0) {
                  /* decode pdpAddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpAddress");

                  ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->
                     pdpAddress);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpAddressPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 2) {
                  /* decode packetFlowIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdent");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 57: {
               if (lastRow <= 3) {
                  /* decode smCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "smCause");

                  ret = NASDec_TS24008IE_SMCause2Value (pctxt, &pvalue->smCause
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.smCausePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateSecondaryPDPCtxtRqst (OSCTXT* pctxt
   , TS24008Msg_ActivateSecondaryPDPCtxtRqst* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateSecondaryPDPCtxtRqst");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode requestedNSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedNSAPI");

   ret = NASDec_TS24008IE_NSAPIValue (pctxt, &pvalue->requestedNSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->requestedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->requestedQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedTI */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedTI");

   ret = NASDec_TS24008IE_LinkedTI (pctxt, &pvalue->linkedTI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 54: {
               if (lastRow == 0) {
                  /* decode trafficFlowTemplate */
                  RTXCTXTPUSHELEMNAME (pctxt, "trafficFlowTemplate");

                  ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->
                     trafficFlowTemplate);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.trafficFlowTemplatePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 2) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateSecondaryPDPCtxtAcc (OSCTXT* pctxt
   , TS24008Msg_ActivateSecondaryPDPCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateSecondaryPDPCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode negotiatedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->negotiatedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode negotiatedQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "negotiatedQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->negotiatedQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

   ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->radioPriority);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 52: {
               if (lastRow == 0) {
                  /* decode packetFlowIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdent");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RequestPDPCtxtAct (OSCTXT* pctxt
   , TS24008Msg_RequestPDPCtxtAct* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestPDPCtxtAct");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode offeredPDPAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "offeredPDPAddress");

   ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->
      offeredPDPAddress);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 40: {
               if (lastRow == 0) {
                  /* decode accessPointName */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

                  ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->
                     accessPointName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessPointNamePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyPDPCtxtRqstNetToMS (OSCTXT* pctxt
   , TS24008Msg_ModifyPDPCtxtRqstNetToMS* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyPDPCtxtRqstNetToMS");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode radioPriority */

   RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

   ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->radioPriority);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->requestedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode newQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "newQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->newQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 43: {
               if (lastRow == 0) {
                  /* decode pdpAddress */
                  RTXCTXTPUSHELEMNAME (pctxt, "pdpAddress");

                  ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->
                     pdpAddress);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.pdpAddressPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 1) {
                  /* decode packetFlowIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdent");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 2) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 54: {
               if (lastRow <= 3) {
                  /* decode trafficFlowTemplate */
                  RTXCTXTPUSHELEMNAME (pctxt, "trafficFlowTemplate");

                  ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->
                     trafficFlowTemplate);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.trafficFlowTemplatePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyPDPCtxtRqstMSToNet (OSCTXT* pctxt
   , TS24008Msg_ModifyPDPCtxtRqstMSToNet* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyPDPCtxtRqstMSToNet");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 50: {
               if (lastRow == 0) {
                  /* decode requestedLLCSAPI */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestedLLCSAPI");

                  ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->
                     requestedLLCSAPI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestedLLCSAPIPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 48: {
               if (lastRow <= 1) {
                  /* decode requestedNewQOS */
                  RTXCTXTPUSHELEMNAME (pctxt, "requestedNewQOS");

                  ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->
                     requestedNewQOS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.requestedNewQOSPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 49: {
               if (lastRow <= 2) {
                  /* decode newTFT */
                  RTXCTXTPUSHELEMNAME (pctxt, "newTFT");

                  ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->newTFT);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.newTFTPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 3) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 4) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyPDPCtxtAccMSToNet (OSCTXT* pctxt
   , TS24008Msg_ModifyPDPCtxtAccMSToNet* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyPDPCtxtAccMSToNet");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ModifyPDPCtxtAccNetToMS (OSCTXT* pctxt
   , TS24008Msg_ModifyPDPCtxtAccNetToMS* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModifyPDPCtxtAccNetToMS");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 48: {
               if (lastRow == 0) {
                  /* decode negotiatedQOS */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedQOS");

                  ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->
                     negotiatedQOS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedQOSPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 1) {
                  /* decode negotiatedLLCSAPI */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

                  ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->
                     negotiatedLLCSAPI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedLLCSAPIPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 2) {
                  /* decode newRadioPriority */
                  RTXCTXTPUSHELEMNAME (pctxt, "newRadioPriority");

                  ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->
                     newRadioPriority);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.newRadioPriorityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 3) {
                  /* decode packetFlowIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdent");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 4) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_DeactivatePDPCtxtReq (OSCTXT* pctxt
   , TS24008Msg_DeactivatePDPCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactivatePDPCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode smCause */

   RTXCTXTPUSHELEMNAME (pctxt, "smCause");

   ret = NASDec_TS24008IE_SMCauseValue (pctxt, &pvalue->smCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 9) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 9: {
               if (lastRow == 0) {
                  /* decode tearDownIndicator */
                  RTXCTXTPUSHELEMNAME (pctxt, "tearDownIndicator");

                  ret = NASDec_TS24008IE_TDIValue (pctxt, &pvalue->
                     tearDownIndicator);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tearDownIndicatorPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 2) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 3) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_DeactivatePDPCtxtAcc (OSCTXT* pctxt
   , TS24008Msg_DeactivatePDPCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactivatePDPCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 53: {
               if (lastRow <= 1) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RqstSecondaryPDPCtxtAct (OSCTXT* pctxt
   , TS24008Msg_RqstSecondaryPDPCtxtAct* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RqstSecondaryPDPCtxtAct");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode requiredQOS */

   RTXCTXTPUSHELEMNAME (pctxt, "requiredQOS");

   ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->requiredQOS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedTI */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedTI");

   ret = NASDec_TS24008IE_LinkedTI (pctxt, &pvalue->linkedTI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 54: {
               if (lastRow == 0) {
                  /* decode trafficFlowTemplate */
                  RTXCTXTPUSHELEMNAME (pctxt, "trafficFlowTemplate");

                  ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->
                     trafficFlowTemplate);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.trafficFlowTemplatePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateMBMSCtxtReq (OSCTXT* pctxt
   , TS24008Msg_ActivateMBMSCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateMBMSCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode requestedMBMSNSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedMBMSNSAPI");

   ret = NASDec_TS24008IE_EnhancedNSAPIValue (pctxt, &pvalue->
      requestedMBMSNSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->requestedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode supportedMBMSBearerCaps */

   RTXCTXTPUSHELEMNAME (pctxt, "supportedMBMSBearerCaps");

   ret = NASDec_TS24008IE_MBMSBearerCaps (pctxt, &pvalue->
      supportedMBMSBearerCaps);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestedMulticastAddr */

   RTXCTXTPUSHELEMNAME (pctxt, "requestedMulticastAddr");

   ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->
      requestedMulticastAddr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode accessPointName */

   RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

   ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->accessPointName);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         else if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 53: {
               if (lastRow == 0) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 1) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!knownTVType1) {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_ActivateMBMSCtxtAcc (OSCTXT* pctxt
   , TS24008Msg_ActivateMBMSCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActivateMBMSCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode tmgi */

   RTXCTXTPUSHELEMNAME (pctxt, "tmgi");

   ret = NASDec_TS24008IE_TMGI (pctxt, &pvalue->tmgi);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode negotiatedLLCSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

   ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->negotiatedLLCSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 53: {
               if (lastRow == 0) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_RequestMBMSCtxtAct (OSCTXT* pctxt
   , TS24008Msg_RequestMBMSCtxtAct* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RequestMBMSCtxtAct");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode linkedNSAPI */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedNSAPI");

   ret = NASDec_TS24008IE_NSAPIValue (pctxt, &pvalue->linkedNSAPI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode offeredMulticastAddr */

   RTXCTXTPUSHELEMNAME (pctxt, "offeredMulticastAddr");

   ret = NASDec_TS24008IE_PacketDataProtoAddr (pctxt, &pvalue->
      offeredMulticastAddr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode accessPointName */

   RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

   ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->accessPointName);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;
      OSUINT8 lockedCodeset = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSUINT8 activeCodeset = lockedCodeset;
         OSBOOL  unknownIEI = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == SHIFT_IEI) {
            OSUINT8 codeset = iei & 0x07;
            OSBOOL locking = (iei & 0x08) == 0;
            if (locking && codeset > lockedCodeset) {
               lockedCodeset = activeCodeset = codeset;
            }
            else if (!locking) activeCodeset = codeset;

            continue;
         }

         if (activeCodeset != 0) {
            unknownIEI = TRUE;
         }
         else switch (iei) {
            case 53: {
               if (lastRow == 0) {
                  /* decode mbmsPCO */
                  RTXCTXTPUSHELEMNAME (pctxt, "mbmsPCO");

                  ret = NASDec_TS24008IE_MBMS_PCO (pctxt, &pvalue->mbmsPCO);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mbmsPCOPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: unknownIEI = TRUE;
         }

         if (unknownIEI) {
            if (!(iei & 0x80)) {
               ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
               if (0 != ret) return LOG_RTERR (pctxt, ret);

               comprReqd = (OSBOOL)((iei & 0x0F) == 0 && activeCodeset == 0);
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24008Msg_PDU (OSCTXT* pctxt, TS24008Msg_PDU* pvalue)
{
   OSBOOL present;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDU");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode l3HdrOpts */

   RTXCTXTPUSHELEMNAME (pctxt, "l3HdrOpts");

   ret = NASDec_TS24007L3_L3HdrOptions (pctxt, &pvalue->l3HdrOpts);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24007L3_ProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode sendSeqNum */

   /* begin custom source file TS24008MsgDec_PDU_sendSeqNum.c */

   /* sendSeqNum is decoded as part of the id.msgType element */

   /* end custom source file TS24008MsgDec_PDU_sendSeqNum.c */

   /* decode msgType */

   /* begin custom source file TS24008MsgDec_PDU_msgType.c */

   {
      if (pvalue->protoDiscr == TS24007L3_ProtoDiscr_callCtrl ||
          pvalue->protoDiscr == TS24007L3_ProtoDiscr_sessMgmt) 
      {
         OSUINT8 tmpval = pvalue->l3HdrOpts.u.skipInd;
   
         pvalue->l3HdrOpts.t = T_TS24007L3_L3HdrOptions_transId;
         pvalue->l3HdrOpts.u.transId.flag = (OSBOOL)((tmpval & 0x08) != 0);
   
         if ((tmpval & 0x07) == 7) {
            RTXCTXTPUSHELEMNAME (pctxt, "transId");
            RTDIAG_NEWBITFIELD (pctxt, "flag");
   
            ret = rtxSkipBits (pctxt, 1);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
   
            RTDIAG_SETBITFLDCOUNT (pctxt);
   
            RTDIAG_NEWBITFIELD (pctxt, "INTEGER");
   
            ret = rtxDecBitsToByte 
               (pctxt, &pvalue->l3HdrOpts.u.transId.value, 7);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
   
            RTDIAG_SETBITFLDCOUNT (pctxt);
            RTXCTXTPOPELEMNAME (pctxt);
         }
         else {
            pvalue->l3HdrOpts.u.transId.value = tmpval & 0x07;
         }
      }
   
      RTXCTXTPUSHELEMNAME (pctxt, "msgType");
      RTDIAG_NEWBITFIELD (pctxt, "INTEGER");
   
      ret = rtxDecBitsToByte (pctxt, &pvalue->msgType, 8);
      if (0 != ret) return LOG_RTERR (pctxt, ret);
   
      RTDIAG_SETBITFLDCOUNT (pctxt);
      RTXCTXTPOPELEMNAME (pctxt);
   
      /* for callCtrl or mobMgmt, sendSeqNum is stored in upper 2 bits 
         of msgType */
   
      if (pvalue->protoDiscr == TS24007L3_ProtoDiscr_callCtrl ||
          pvalue->protoDiscr == TS24007L3_ProtoDiscr_mobMgmt)
      {
         pvalue->sendSeqNum = (pvalue->msgType & 0xC0) >> 6;
         pvalue->m.sendSeqNumPresent = (pvalue->sendSeqNum != 0);
   
         pvalue->msgType &= 0x3F;
      }
   }

   /* end custom source file TS24008MsgDec_PDU_msgType.c */

   /* decode data */

   RTXCTXTPUSHELEMNAME (pctxt, "data");

   switch (pvalue->protoDiscr) {
   case TS24007L3_ProtoDiscr_mobMgmt:
      switch (pvalue->msgType) {
      case ASN1V_mt_AuthenticationReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthenticationReject;

         break;

      case ASN1V_mt_AuthenticationRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthenticationRequest;

         pvalue->data.u.obj_AuthenticationRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthenticationRequest);

         if (pvalue->data.u.obj_AuthenticationRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthenticationRequest (pvalue->data.
            u.obj_AuthenticationRequest);

         ret = NASDec_TS24008Msg_AuthenticationRequest (pctxt, pvalue->data.
            u.obj_AuthenticationRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AuthenticationResponse:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthenticationResponse;

         pvalue->data.u.obj_AuthenticationResponse = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthenticationResponse);

         if (pvalue->data.u.obj_AuthenticationResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthenticationResponse (pvalue->data.
            u.obj_AuthenticationResponse);

         ret = NASDec_TS24008Msg_AuthenticationResponse (pctxt, pvalue->data.
            u.obj_AuthenticationResponse);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AuthenticationFailure:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthenticationFailure;

         pvalue->data.u.obj_AuthenticationFailure = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthenticationFailure);

         if (pvalue->data.u.obj_AuthenticationFailure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthenticationFailure (pvalue->data.
            u.obj_AuthenticationFailure);

         ret = NASDec_TS24008Msg_AuthenticationFailure (pctxt, pvalue->data.
            u.obj_AuthenticationFailure);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CMReestabRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMReestabRequest;

         pvalue->data.u.obj_CMReestabRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_CMReestabRequest);

         if (pvalue->data.u.obj_CMReestabRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CMReestabRequest (pvalue->data.
            u.obj_CMReestabRequest);

         ret = NASDec_TS24008Msg_CMReestabRequest (pctxt, pvalue->data.
            u.obj_CMReestabRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CMServiceAccept:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMServiceAccept;

         break;

      case ASN1V_mt_CMServicePrompt:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMServicePrompt;

         pvalue->data.u.obj_CMServicePrompt = rtxMemAllocType (pctxt, 
            TS24008Msg_CMServicePrompt);

         if (pvalue->data.u.obj_CMServicePrompt == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CMServicePrompt (pvalue->data.
            u.obj_CMServicePrompt);

         ret = NASDec_TS24008Msg_CMServicePrompt (pctxt, pvalue->data.
            u.obj_CMServicePrompt);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CMServiceReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMServiceReject;

         pvalue->data.u.obj_CMServiceReject = rtxMemAllocType (pctxt, 
            TS24008Msg_CMServiceReject);

         if (pvalue->data.u.obj_CMServiceReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CMServiceReject (pvalue->data.
            u.obj_CMServiceReject);

         ret = NASDec_TS24008Msg_CMServiceReject (pctxt, pvalue->data.
            u.obj_CMServiceReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CMServiceAbort:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMServiceAbort;

         break;

      case ASN1V_mt_Abort:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Abort;

         pvalue->data.u.obj_Abort = rtxMemAllocTypeZ (pctxt, 
            TS24008Msg_Abort);

         if (pvalue->data.u.obj_Abort == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         ret = NASDec_TS24008Msg_Abort (pctxt, pvalue->data.u.obj_Abort);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CMServiceRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CMServiceRequest;

         pvalue->data.u.obj_CMServiceRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_CMServiceRequest);

         if (pvalue->data.u.obj_CMServiceRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CMServiceRequest (pvalue->data.
            u.obj_CMServiceRequest);

         ret = NASDec_TS24008Msg_CMServiceRequest (pctxt, pvalue->data.
            u.obj_CMServiceRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_IdentityRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_IdentityRequest;

         pvalue->data.u.obj_IdentityRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_IdentityRequest);

         if (pvalue->data.u.obj_IdentityRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_IdentityRequest (pvalue->data.
            u.obj_IdentityRequest);

         ret = NASDec_TS24008Msg_IdentityRequest (pctxt, pvalue->data.
            u.obj_IdentityRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_IdentityResponse:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_IdentityResponse;

         pvalue->data.u.obj_IdentityResponse = rtxMemAllocType (pctxt, 
            TS24008Msg_IdentityResponse);

         if (pvalue->data.u.obj_IdentityResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_IdentityResponse (pvalue->data.
            u.obj_IdentityResponse);

         ret = NASDec_TS24008Msg_IdentityResponse (pctxt, pvalue->data.
            u.obj_IdentityResponse);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_IMSIDetachInd:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_IMSIDetachInd;

         pvalue->data.u.obj_IMSIDetachInd = rtxMemAllocType (pctxt, 
            TS24008Msg_IMSIDetachInd);

         if (pvalue->data.u.obj_IMSIDetachInd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_IMSIDetachInd (pvalue->data.u.obj_IMSIDetachInd);

         ret = NASDec_TS24008Msg_IMSIDetachInd (pctxt, pvalue->data.
            u.obj_IMSIDetachInd);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_LocUpdatingAccept:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_LocUpdatingAccept;

         pvalue->data.u.obj_LocUpdatingAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_LocUpdatingAccept);

         if (pvalue->data.u.obj_LocUpdatingAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_LocUpdatingAccept (pvalue->data.
            u.obj_LocUpdatingAccept);

         ret = NASDec_TS24008Msg_LocUpdatingAccept (pctxt, pvalue->data.
            u.obj_LocUpdatingAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_LocUpdatingReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_LocUpdatingReject;

         pvalue->data.u.obj_LocUpdatingReject = rtxMemAllocType (pctxt, 
            TS24008Msg_LocUpdatingReject);

         if (pvalue->data.u.obj_LocUpdatingReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_LocUpdatingReject (pvalue->data.
            u.obj_LocUpdatingReject);

         ret = NASDec_TS24008Msg_LocUpdatingReject (pctxt, pvalue->data.
            u.obj_LocUpdatingReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_LocUpdatingRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_LocUpdatingRequest;

         pvalue->data.u.obj_LocUpdatingRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_LocUpdatingRequest);

         if (pvalue->data.u.obj_LocUpdatingRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_LocUpdatingRequest (pvalue->data.
            u.obj_LocUpdatingRequest);

         ret = NASDec_TS24008Msg_LocUpdatingRequest (pctxt, pvalue->data.
            u.obj_LocUpdatingRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_MMInformation:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_MMInformation;

         pvalue->data.u.obj_MMInformation = rtxMemAllocType (pctxt, 
            TS24008Msg_MMInformation);

         if (pvalue->data.u.obj_MMInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_MMInformation (pvalue->data.u.obj_MMInformation);

         ret = NASDec_TS24008Msg_MMInformation (pctxt, pvalue->data.
            u.obj_MMInformation);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_MMStatus:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_MMStatus;

         pvalue->data.u.obj_MMStatus = rtxMemAllocTypeZ (pctxt, 
            TS24008Msg_MMStatus);

         if (pvalue->data.u.obj_MMStatus == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         ret = NASDec_TS24008Msg_MMStatus (pctxt, pvalue->data.u.obj_MMStatus
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_TMSIReallocCmd:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_TMSIReallocCmd;

         pvalue->data.u.obj_TMSIReallocCmd = rtxMemAllocType (pctxt, 
            TS24008Msg_TMSIReallocCmd);

         if (pvalue->data.u.obj_TMSIReallocCmd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_TMSIReallocCmd (pvalue->data.u.obj_TMSIReallocCmd
            );

         ret = NASDec_TS24008Msg_TMSIReallocCmd (pctxt, pvalue->data.
            u.obj_TMSIReallocCmd);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_TMSIReallocCmplt:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_TMSIReallocCmplt;

         break;

      case ASN1V_mt_MMNull:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_MMNull;

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   case TS24007L3_ProtoDiscr_callCtrl:
      switch (pvalue->msgType) {
      case ASN1V_mt_Alerting:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Alerting;

         pvalue->data.u.obj_Alerting = rtxMemAllocType (pctxt, 
            TS24008Msg_Alerting);

         if (pvalue->data.u.obj_Alerting == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Alerting (pvalue->data.u.obj_Alerting);

         ret = NASDec_TS24008Msg_Alerting (pctxt, pvalue->data.u.obj_Alerting
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CallConfirmed:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CallConfirmed;

         pvalue->data.u.obj_CallConfirmed = rtxMemAllocType (pctxt, 
            TS24008Msg_CallConfirmed);

         if (pvalue->data.u.obj_CallConfirmed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CallConfirmed (pvalue->data.u.obj_CallConfirmed);

         ret = NASDec_TS24008Msg_CallConfirmed (pctxt, pvalue->data.
            u.obj_CallConfirmed);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CallProceeding:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CallProceeding;

         pvalue->data.u.obj_CallProceeding = rtxMemAllocType (pctxt, 
            TS24008Msg_CallProceeding);

         if (pvalue->data.u.obj_CallProceeding == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CallProceeding (pvalue->data.u.obj_CallProceeding
            );

         ret = NASDec_TS24008Msg_CallProceeding (pctxt, pvalue->data.
            u.obj_CallProceeding);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CongestionControl:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CongestionControl;

         pvalue->data.u.obj_CongestionControl = rtxMemAllocType (pctxt, 
            TS24008Msg_CongestionControl);

         if (pvalue->data.u.obj_CongestionControl == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CongestionControl (pvalue->data.
            u.obj_CongestionControl);

         ret = NASDec_TS24008Msg_CongestionControl (pctxt, pvalue->data.
            u.obj_CongestionControl);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Connect:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Connect;

         pvalue->data.u.obj_Connect = rtxMemAllocType (pctxt, 
            TS24008Msg_Connect);

         if (pvalue->data.u.obj_Connect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Connect (pvalue->data.u.obj_Connect);

         ret = NASDec_TS24008Msg_Connect (pctxt, pvalue->data.u.obj_Connect);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ConnectAck:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ConnectAck;

         break;

      case ASN1V_mt_Disconnect:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Disconnect;

         pvalue->data.u.obj_Disconnect = rtxMemAllocType (pctxt, 
            TS24008Msg_Disconnect);

         if (pvalue->data.u.obj_Disconnect == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Disconnect (pvalue->data.u.obj_Disconnect);

         ret = NASDec_TS24008Msg_Disconnect (pctxt, pvalue->data.
            u.obj_Disconnect);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_EmergencySetup:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_EmergencySetup;

         pvalue->data.u.obj_EmergencySetup = rtxMemAllocType (pctxt, 
            TS24008Msg_EmergencySetup);

         if (pvalue->data.u.obj_EmergencySetup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_EmergencySetup (pvalue->data.u.obj_EmergencySetup
            );

         ret = NASDec_TS24008Msg_EmergencySetup (pctxt, pvalue->data.
            u.obj_EmergencySetup);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_FacilityMsg:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_FacilityMsg;

         pvalue->data.u.obj_FacilityMsg = rtxMemAllocType (pctxt, 
            TS24008Msg_FacilityMsg);

         if (pvalue->data.u.obj_FacilityMsg == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_FacilityMsg (pvalue->data.u.obj_FacilityMsg);

         ret = NASDec_TS24008Msg_FacilityMsg (pctxt, pvalue->data.
            u.obj_FacilityMsg);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Hold:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Hold;

         break;

      case ASN1V_mt_HoldAck:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_HoldAck;

         break;

      case ASN1V_mt_HoldReject:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_HoldReject;

         pvalue->data.u.obj_HoldReject = rtxMemAllocType (pctxt, 
            TS24008IE_Cause);

         if (pvalue->data.u.obj_HoldReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008IE_Cause (pvalue->data.u.obj_HoldReject);

         ret = NASDec_TS24008IE_Cause (pctxt, pvalue->data.u.obj_HoldReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Modify:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Modify;

         pvalue->data.u.obj_Modify = rtxMemAllocType (pctxt, 
            TS24008Msg_Modify);

         if (pvalue->data.u.obj_Modify == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Modify (pvalue->data.u.obj_Modify);

         ret = NASDec_TS24008Msg_Modify (pctxt, pvalue->data.u.obj_Modify);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyComplete:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyComplete;

         pvalue->data.u.obj_ModifyComplete = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyComplete);

         if (pvalue->data.u.obj_ModifyComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyComplete (pvalue->data.u.obj_ModifyComplete
            );

         ret = NASDec_TS24008Msg_ModifyComplete (pctxt, pvalue->data.
            u.obj_ModifyComplete);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyReject:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyReject;

         pvalue->data.u.obj_ModifyReject = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyReject);

         if (pvalue->data.u.obj_ModifyReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyReject (pvalue->data.u.obj_ModifyReject);

         ret = NASDec_TS24008Msg_ModifyReject (pctxt, pvalue->data.
            u.obj_ModifyReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Notify:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Notify;

         pvalue->data.u.obj_Notify = rtxMemAllocType (pctxt, 
            TS24008IE_NotificationIndicator);

         if (pvalue->data.u.obj_Notify == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008IE_NotificationIndicator (pvalue->data.u.obj_Notify);

         ret = NASDec_TS24008IE_NotificationIndicator (pctxt, pvalue->data.
            u.obj_Notify);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Progress:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Progress;

         pvalue->data.u.obj_Progress = rtxMemAllocType (pctxt, 
            TS24008Msg_Progress);

         if (pvalue->data.u.obj_Progress == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Progress (pvalue->data.u.obj_Progress);

         ret = NASDec_TS24008Msg_Progress (pctxt, pvalue->data.u.obj_Progress
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CC_Establishment:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CC_Establishment;

         pvalue->data.u.obj_CC_Establishment = rtxMemAllocType (pctxt, 
            TS24008IE_Setup_Container);

         if (pvalue->data.u.obj_CC_Establishment == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008IE_Setup_Container (pvalue->data.
            u.obj_CC_Establishment);

         ret = NASDec_TS24008IE_Setup_Container (pctxt, pvalue->data.
            u.obj_CC_Establishment);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_CC_EstablishmentConfirmed:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_CC_EstablishmentConfirmed;

         pvalue->data.u.obj_CC_EstablishmentConfirmed
             = rtxMemAllocType (pctxt, TS24008Msg_CC_EstablishmentConfirmed);

         if (pvalue->data.u.obj_CC_EstablishmentConfirmed == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_CC_EstablishmentConfirmed (pvalue->data.
            u.obj_CC_EstablishmentConfirmed);

         ret = NASDec_TS24008Msg_CC_EstablishmentConfirmed (pctxt, pvalue->data
            .u.obj_CC_EstablishmentConfirmed);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Release:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Release;

         pvalue->data.u.obj_Release = rtxMemAllocType (pctxt, 
            TS24008Msg_Release);

         if (pvalue->data.u.obj_Release == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Release (pvalue->data.u.obj_Release);

         ret = NASDec_TS24008Msg_Release (pctxt, pvalue->data.u.obj_Release);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Recall:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Recall;

         pvalue->data.u.obj_Recall = rtxMemAllocType (pctxt, 
            TS24008Msg_Recall);

         if (pvalue->data.u.obj_Recall == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Recall (pvalue->data.u.obj_Recall);

         ret = NASDec_TS24008Msg_Recall (pctxt, pvalue->data.u.obj_Recall);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ReleaseComplete:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ReleaseComplete;

         pvalue->data.u.obj_ReleaseComplete = rtxMemAllocType (pctxt, 
            TS24008Msg_ReleaseComplete);

         if (pvalue->data.u.obj_ReleaseComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ReleaseComplete (pvalue->data.
            u.obj_ReleaseComplete);

         ret = NASDec_TS24008Msg_ReleaseComplete (pctxt, pvalue->data.
            u.obj_ReleaseComplete);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Retrieve:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Retrieve;

         break;

      case ASN1V_mt_RetrieveAck:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RetrieveAck;

         break;

      case ASN1V_mt_RetrieveReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RetrieveReject;

         pvalue->data.u.obj_RetrieveReject = rtxMemAllocType (pctxt, 
            TS24008IE_Cause);

         if (pvalue->data.u.obj_RetrieveReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008IE_Cause (pvalue->data.u.obj_RetrieveReject);

         ret = NASDec_TS24008IE_Cause (pctxt, pvalue->data.u.obj_RetrieveReject
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Setup:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Setup;

         pvalue->data.u.obj_Setup = rtxMemAllocType (pctxt, TS24008Msg_Setup);

         if (pvalue->data.u.obj_Setup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Setup (pvalue->data.u.obj_Setup);

         ret = NASDec_TS24008Msg_Setup (pctxt, pvalue->data.u.obj_Setup);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_StartCC:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StartCC;

         pvalue->data.u.obj_StartCC = rtxMemAllocType (pctxt, 
            TS24008Msg_StartCC);

         if (pvalue->data.u.obj_StartCC == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_StartCC (pvalue->data.u.obj_StartCC);

         ret = NASDec_TS24008Msg_StartCC (pctxt, pvalue->data.u.obj_StartCC);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_StartDTMF:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StartDTMF;

         pvalue->data.u.obj_StartDTMF = rtxMemAllocType (pctxt, 
            TS24008Msg_StartDTMF);

         if (pvalue->data.u.obj_StartDTMF == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_StartDTMF (pvalue->data.u.obj_StartDTMF);

         ret = NASDec_TS24008Msg_StartDTMF (pctxt, pvalue->data.u.obj_StartDTMF
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_StartDTMFAck:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StartDTMFAck;

         pvalue->data.u.obj_StartDTMFAck = rtxMemAllocType (pctxt, 
            TS24008Msg_StartDTMFAck);

         if (pvalue->data.u.obj_StartDTMFAck == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_StartDTMFAck (pvalue->data.u.obj_StartDTMFAck);

         ret = NASDec_TS24008Msg_StartDTMFAck (pctxt, pvalue->data.
            u.obj_StartDTMFAck);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_StartDTMFReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StartDTMFReject;

         pvalue->data.u.obj_StartDTMFReject = rtxMemAllocType (pctxt, 
            TS24008IE_Cause);

         if (pvalue->data.u.obj_StartDTMFReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008IE_Cause (pvalue->data.u.obj_StartDTMFReject);

         ret = NASDec_TS24008IE_Cause (pctxt, pvalue->data.
            u.obj_StartDTMFReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_Status:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_Status;

         pvalue->data.u.obj_Status = rtxMemAllocType (pctxt, 
            TS24008Msg_Status);

         if (pvalue->data.u.obj_Status == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_Status (pvalue->data.u.obj_Status);

         ret = NASDec_TS24008Msg_Status (pctxt, pvalue->data.u.obj_Status);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_StatusEnquiry:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StatusEnquiry;

         break;

      case ASN1V_mt_StopDTMF:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StopDTMF;

         break;

      case ASN1V_mt_StopDTMFAck:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_StopDTMFAck;

         break;

      case ASN1V_mt_UserInfo:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_UserInfo;

         pvalue->data.u.obj_UserInfo = rtxMemAllocType (pctxt, 
            TS24008Msg_UserInfo);

         if (pvalue->data.u.obj_UserInfo == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_UserInfo (pvalue->data.u.obj_UserInfo);

         ret = NASDec_TS24008Msg_UserInfo (pctxt, pvalue->data.u.obj_UserInfo
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   case TS24007L3_ProtoDiscr_gprsMobMgmt:
      switch (pvalue->msgType) {
      case ASN1V_mt_AttachRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AttachRequest;

         pvalue->data.u.obj_AttachRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_AttachRequest);

         if (pvalue->data.u.obj_AttachRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AttachRequest (pvalue->data.u.obj_AttachRequest);

         ret = NASDec_TS24008Msg_AttachRequest (pctxt, pvalue->data.
            u.obj_AttachRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AttachAccept:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AttachAccept;

         pvalue->data.u.obj_AttachAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_AttachAccept);

         if (pvalue->data.u.obj_AttachAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AttachAccept (pvalue->data.u.obj_AttachAccept);

         ret = NASDec_TS24008Msg_AttachAccept (pctxt, pvalue->data.
            u.obj_AttachAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AttachComplete:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AttachComplete;

         pvalue->data.u.obj_AttachComplete = rtxMemAllocType (pctxt, 
            TS24008Msg_AttachComplete);

         if (pvalue->data.u.obj_AttachComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AttachComplete (pvalue->data.u.obj_AttachComplete
            );

         ret = NASDec_TS24008Msg_AttachComplete (pctxt, pvalue->data.
            u.obj_AttachComplete);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AttachReject:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AttachReject;

         pvalue->data.u.obj_AttachReject = rtxMemAllocType (pctxt, 
            TS24008Msg_AttachReject);

         if (pvalue->data.u.obj_AttachReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AttachReject (pvalue->data.u.obj_AttachReject);

         ret = NASDec_TS24008Msg_AttachReject (pctxt, pvalue->data.
            u.obj_AttachReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_DetachRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_DetachRequest;

         pvalue->data.u.obj_DetachRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_DetachRequest);

         if (pvalue->data.u.obj_DetachRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_DetachRequest (pvalue->data.u.obj_DetachRequest);

         ret = NASDec_TS24008Msg_DetachRequest (pctxt, pvalue->data.
            u.obj_DetachRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_DetachAccept:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_DetachAccept;

         pvalue->data.u.obj_DetachAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_DetachAccept);

         if (pvalue->data.u.obj_DetachAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_DetachAccept (pvalue->data.u.obj_DetachAccept);

         ret = NASDec_TS24008Msg_DetachAccept (pctxt, pvalue->data.
            u.obj_DetachAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_P_TMSIReallocCmd:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_P_TMSIReallocCmd;

         pvalue->data.u.obj_P_TMSIReallocCmd = rtxMemAllocType (pctxt, 
            TS24008Msg_P_TMSIReallocCmd);

         if (pvalue->data.u.obj_P_TMSIReallocCmd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_P_TMSIReallocCmd (pvalue->data.
            u.obj_P_TMSIReallocCmd);

         ret = NASDec_TS24008Msg_P_TMSIReallocCmd (pctxt, pvalue->data.
            u.obj_P_TMSIReallocCmd);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_P_TMSIReallocCmplt:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_P_TMSIReallocCmplt;

         break;

      case ASN1V_mt_AuthAndCiphRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthAndCiphRequest;

         pvalue->data.u.obj_AuthAndCiphRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthAndCiphRequest);

         if (pvalue->data.u.obj_AuthAndCiphRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthAndCiphRequest (pvalue->data.
            u.obj_AuthAndCiphRequest);

         ret = NASDec_TS24008Msg_AuthAndCiphRequest (pctxt, pvalue->data.
            u.obj_AuthAndCiphRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AuthAndCiphResponse:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthAndCiphResponse;

         pvalue->data.u.obj_AuthAndCiphResponse = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthAndCiphResponse);

         if (pvalue->data.u.obj_AuthAndCiphResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthAndCiphResponse (pvalue->data.
            u.obj_AuthAndCiphResponse);

         ret = NASDec_TS24008Msg_AuthAndCiphResponse (pctxt, pvalue->data.
            u.obj_AuthAndCiphResponse);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AuthAndCiphFailure:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthAndCiphFailure;

         pvalue->data.u.obj_AuthAndCiphFailure = rtxMemAllocType (pctxt, 
            TS24008Msg_AuthAndCiphFailure);

         if (pvalue->data.u.obj_AuthAndCiphFailure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_AuthAndCiphFailure (pvalue->data.
            u.obj_AuthAndCiphFailure);

         ret = NASDec_TS24008Msg_AuthAndCiphFailure (pctxt, pvalue->data.
            u.obj_AuthAndCiphFailure);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_AuthAndCiphReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_AuthAndCiphReject;

         break;

      case ASN1V_mt_GMMIdentityRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_GMMIdentityRequest;

         pvalue->data.u.obj_GMMIdentityRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_GMMIdentityRequest);

         if (pvalue->data.u.obj_GMMIdentityRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_GMMIdentityRequest (pvalue->data.
            u.obj_GMMIdentityRequest);

         ret = NASDec_TS24008Msg_GMMIdentityRequest (pctxt, pvalue->data.
            u.obj_GMMIdentityRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_GMMIdentityResponse:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_GMMIdentityResponse;

         pvalue->data.u.obj_GMMIdentityResponse = rtxMemAllocType (pctxt, 
            TS24008Msg_GMMIdentityResponse);

         if (pvalue->data.u.obj_GMMIdentityResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_GMMIdentityResponse (pvalue->data.
            u.obj_GMMIdentityResponse);

         ret = NASDec_TS24008Msg_GMMIdentityResponse (pctxt, pvalue->data.
            u.obj_GMMIdentityResponse);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RoutingAreaUpdateRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RoutingAreaUpdateRequest;

         pvalue->data.u.obj_RoutingAreaUpdateRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_RoutingAreaUpdateRequest);

         if (pvalue->data.u.obj_RoutingAreaUpdateRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RoutingAreaUpdateRequest (pvalue->data.
            u.obj_RoutingAreaUpdateRequest);

         ret = NASDec_TS24008Msg_RoutingAreaUpdateRequest (pctxt, pvalue->data.
            u.obj_RoutingAreaUpdateRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RoutingAreaUpdateAccept:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RoutingAreaUpdateAccept;

         pvalue->data.u.obj_RoutingAreaUpdateAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_RoutingAreaUpdateAccept);

         if (pvalue->data.u.obj_RoutingAreaUpdateAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RoutingAreaUpdateAccept (pvalue->data.
            u.obj_RoutingAreaUpdateAccept);

         ret = NASDec_TS24008Msg_RoutingAreaUpdateAccept (pctxt, pvalue->data.
            u.obj_RoutingAreaUpdateAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RoutingAreaUpdateComplete:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RoutingAreaUpdateComplete;

         pvalue->data.u.obj_RoutingAreaUpdateComplete
             = rtxMemAllocType (pctxt, TS24008Msg_RoutingAreaUpdateComplete);

         if (pvalue->data.u.obj_RoutingAreaUpdateComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RoutingAreaUpdateComplete (pvalue->data.
            u.obj_RoutingAreaUpdateComplete);

         ret = NASDec_TS24008Msg_RoutingAreaUpdateComplete (pctxt, pvalue->data
            .u.obj_RoutingAreaUpdateComplete);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RoutingAreaUpdateReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RoutingAreaUpdateReject;

         pvalue->data.u.obj_RoutingAreaUpdateReject = rtxMemAllocType (pctxt, 
            TS24008Msg_RoutingAreaUpdateReject);

         if (pvalue->data.u.obj_RoutingAreaUpdateReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RoutingAreaUpdateReject (pvalue->data.
            u.obj_RoutingAreaUpdateReject);

         ret = NASDec_TS24008Msg_RoutingAreaUpdateReject (pctxt, pvalue->data.
            u.obj_RoutingAreaUpdateReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_GMMStatus:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_GMMStatus;

         ret = NASDec_TS24008IE_GMMCauseValue (pctxt, &pvalue->data.
            u.obj_GMMStatus);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_GMMInformation:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_GMMInformation;

         pvalue->data.u.obj_GMMInformation = rtxMemAllocType (pctxt, 
            TS24008Msg_GMMInformation);

         if (pvalue->data.u.obj_GMMInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_GMMInformation (pvalue->data.u.obj_GMMInformation
            );

         ret = NASDec_TS24008Msg_GMMInformation (pctxt, pvalue->data.
            u.obj_GMMInformation);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ServiceRequest:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ServiceRequest;

         pvalue->data.u.obj_ServiceRequest = rtxMemAllocType (pctxt, 
            TS24008Msg_ServiceRequest);

         if (pvalue->data.u.obj_ServiceRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ServiceRequest (pvalue->data.u.obj_ServiceRequest
            );

         ret = NASDec_TS24008Msg_ServiceRequest (pctxt, pvalue->data.
            u.obj_ServiceRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ServiceAccept:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ServiceAccept;

         pvalue->data.u.obj_ServiceAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_ServiceAccept);

         if (pvalue->data.u.obj_ServiceAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ServiceAccept (pvalue->data.u.obj_ServiceAccept);

         ret = NASDec_TS24008Msg_ServiceAccept (pctxt, pvalue->data.
            u.obj_ServiceAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ServiceReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ServiceReject;

         pvalue->data.u.obj_ServiceReject = rtxMemAllocType (pctxt, 
            TS24008Msg_ServiceReject);

         if (pvalue->data.u.obj_ServiceReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ServiceReject (pvalue->data.u.obj_ServiceReject);

         ret = NASDec_TS24008Msg_ServiceReject (pctxt, pvalue->data.
            u.obj_ServiceReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   case TS24007L3_ProtoDiscr_sessMgmt:
      switch (pvalue->msgType) {
      case ASN1V_mt_ActivatePDPCtxtReq:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivatePDPCtxtReq;

         pvalue->data.u.obj_ActivatePDPCtxtReq = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivatePDPCtxtReq);

         if (pvalue->data.u.obj_ActivatePDPCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivatePDPCtxtReq (pvalue->data.
            u.obj_ActivatePDPCtxtReq);

         ret = NASDec_TS24008Msg_ActivatePDPCtxtReq (pctxt, pvalue->data.
            u.obj_ActivatePDPCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivatePDPCtxtAccept:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivatePDPCtxtAccept;

         pvalue->data.u.obj_ActivatePDPCtxtAccept = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivatePDPCtxtAccept);

         if (pvalue->data.u.obj_ActivatePDPCtxtAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivatePDPCtxtAccept (pvalue->data.
            u.obj_ActivatePDPCtxtAccept);

         ret = NASDec_TS24008Msg_ActivatePDPCtxtAccept (pctxt, pvalue->data.
            u.obj_ActivatePDPCtxtAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivatePDPCtxtReject:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivatePDPCtxtReject;

         pvalue->data.u.obj_ActivatePDPCtxtReject = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivatePDPCtxtReject);

         if (pvalue->data.u.obj_ActivatePDPCtxtReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivatePDPCtxtReject (pvalue->data.
            u.obj_ActivatePDPCtxtReject);

         ret = NASDec_TS24008Msg_ActivatePDPCtxtReject (pctxt, pvalue->data.
            u.obj_ActivatePDPCtxtReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateSecondaryPDPCtxtRqst:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateSecondaryPDPCtxtRqst;

         pvalue->data.u.obj_ActivateSecondaryPDPCtxtRqst
             = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateSecondaryPDPCtxtRqst);

         if (pvalue->data.u.obj_ActivateSecondaryPDPCtxtRqst == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateSecondaryPDPCtxtRqst (pvalue->data.
            u.obj_ActivateSecondaryPDPCtxtRqst);

         ret = NASDec_TS24008Msg_ActivateSecondaryPDPCtxtRqst (pctxt, pvalue->
            data.u.obj_ActivateSecondaryPDPCtxtRqst);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateSecondaryPDPCtxtAcc:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateSecondaryPDPCtxtAcc;

         pvalue->data.u.obj_ActivateSecondaryPDPCtxtAcc
             = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateSecondaryPDPCtxtAcc);

         if (pvalue->data.u.obj_ActivateSecondaryPDPCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateSecondaryPDPCtxtAcc (pvalue->data.
            u.obj_ActivateSecondaryPDPCtxtAcc);

         ret = NASDec_TS24008Msg_ActivateSecondaryPDPCtxtAcc (pctxt, pvalue->
            data.u.obj_ActivateSecondaryPDPCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateSecondaryPDPCtxtRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateSecondaryPDPCtxtRej;

         pvalue->data.u.obj_ActivateSecondaryPDPCtxtRej
             = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateSecondaryPDPCtxtRej);

         if (pvalue->data.u.obj_ActivateSecondaryPDPCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateSecondaryPDPCtxtRej (pvalue->data.
            u.obj_ActivateSecondaryPDPCtxtRej);

         ret = NASDec_TS24008Msg_ActivateSecondaryPDPCtxtRej (pctxt, pvalue->
            data.u.obj_ActivateSecondaryPDPCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RequestPDPCtxtAct:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RequestPDPCtxtAct;

         pvalue->data.u.obj_RequestPDPCtxtAct = rtxMemAllocType (pctxt, 
            TS24008Msg_RequestPDPCtxtAct);

         if (pvalue->data.u.obj_RequestPDPCtxtAct == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RequestPDPCtxtAct (pvalue->data.
            u.obj_RequestPDPCtxtAct);

         ret = NASDec_TS24008Msg_RequestPDPCtxtAct (pctxt, pvalue->data.
            u.obj_RequestPDPCtxtAct);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RequestPDPCtxtActRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RequestPDPCtxtActRej;

         pvalue->data.u.obj_RequestPDPCtxtActRej = rtxMemAllocType (pctxt, 
            TS24008Msg_RequestPDPCtxtActRej);

         if (pvalue->data.u.obj_RequestPDPCtxtActRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RequestPDPCtxtActRej (pvalue->data.
            u.obj_RequestPDPCtxtActRej);

         ret = NASDec_TS24008Msg_RequestPDPCtxtActRej (pctxt, pvalue->data.
            u.obj_RequestPDPCtxtActRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyPDPCtxtRqstNetToMS:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyPDPCtxtRqstNetToMS;

         pvalue->data.u.obj_ModifyPDPCtxtRqstNetToMS = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyPDPCtxtRqstNetToMS);

         if (pvalue->data.u.obj_ModifyPDPCtxtRqstNetToMS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyPDPCtxtRqstNetToMS (pvalue->data.
            u.obj_ModifyPDPCtxtRqstNetToMS);

         ret = NASDec_TS24008Msg_ModifyPDPCtxtRqstNetToMS (pctxt, pvalue->data.
            u.obj_ModifyPDPCtxtRqstNetToMS);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyPDPCtxtRqstMSToNet:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyPDPCtxtRqstMSToNet;

         pvalue->data.u.obj_ModifyPDPCtxtRqstMSToNet = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyPDPCtxtRqstMSToNet);

         if (pvalue->data.u.obj_ModifyPDPCtxtRqstMSToNet == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyPDPCtxtRqstMSToNet (pvalue->data.
            u.obj_ModifyPDPCtxtRqstMSToNet);

         ret = NASDec_TS24008Msg_ModifyPDPCtxtRqstMSToNet (pctxt, pvalue->data.
            u.obj_ModifyPDPCtxtRqstMSToNet);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyPDPCtxtAccMSToNet:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyPDPCtxtAccMSToNet;

         pvalue->data.u.obj_ModifyPDPCtxtAccMSToNet = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyPDPCtxtAccMSToNet);

         if (pvalue->data.u.obj_ModifyPDPCtxtAccMSToNet == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyPDPCtxtAccMSToNet (pvalue->data.
            u.obj_ModifyPDPCtxtAccMSToNet);

         ret = NASDec_TS24008Msg_ModifyPDPCtxtAccMSToNet (pctxt, pvalue->data.
            u.obj_ModifyPDPCtxtAccMSToNet);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyPDPCtxtAccNetToMS:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyPDPCtxtAccNetToMS;

         pvalue->data.u.obj_ModifyPDPCtxtAccNetToMS = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyPDPCtxtAccNetToMS);

         if (pvalue->data.u.obj_ModifyPDPCtxtAccNetToMS == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyPDPCtxtAccNetToMS (pvalue->data.
            u.obj_ModifyPDPCtxtAccNetToMS);

         ret = NASDec_TS24008Msg_ModifyPDPCtxtAccNetToMS (pctxt, pvalue->data.
            u.obj_ModifyPDPCtxtAccNetToMS);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ModifyPDPCtxtRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ModifyPDPCtxtRej;

         pvalue->data.u.obj_ModifyPDPCtxtRej = rtxMemAllocType (pctxt, 
            TS24008Msg_ModifyPDPCtxtRej);

         if (pvalue->data.u.obj_ModifyPDPCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ModifyPDPCtxtRej (pvalue->data.
            u.obj_ModifyPDPCtxtRej);

         ret = NASDec_TS24008Msg_ModifyPDPCtxtRej (pctxt, pvalue->data.
            u.obj_ModifyPDPCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_DeactivatePDPCtxtReq:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_DeactivatePDPCtxtReq;

         pvalue->data.u.obj_DeactivatePDPCtxtReq = rtxMemAllocType (pctxt, 
            TS24008Msg_DeactivatePDPCtxtReq);

         if (pvalue->data.u.obj_DeactivatePDPCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_DeactivatePDPCtxtReq (pvalue->data.
            u.obj_DeactivatePDPCtxtReq);

         ret = NASDec_TS24008Msg_DeactivatePDPCtxtReq (pctxt, pvalue->data.
            u.obj_DeactivatePDPCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_DeactivatePDPCtxtAcc:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_DeactivatePDPCtxtAcc;

         pvalue->data.u.obj_DeactivatePDPCtxtAcc = rtxMemAllocType (pctxt, 
            TS24008Msg_DeactivatePDPCtxtAcc);

         if (pvalue->data.u.obj_DeactivatePDPCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_DeactivatePDPCtxtAcc (pvalue->data.
            u.obj_DeactivatePDPCtxtAcc);

         ret = NASDec_TS24008Msg_DeactivatePDPCtxtAcc (pctxt, pvalue->data.
            u.obj_DeactivatePDPCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RqstSecondaryPDPCtxtAct:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RqstSecondaryPDPCtxtAct;

         pvalue->data.u.obj_RqstSecondaryPDPCtxtAct = rtxMemAllocType (pctxt, 
            TS24008Msg_RqstSecondaryPDPCtxtAct);

         if (pvalue->data.u.obj_RqstSecondaryPDPCtxtAct == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RqstSecondaryPDPCtxtAct (pvalue->data.
            u.obj_RqstSecondaryPDPCtxtAct);

         ret = NASDec_TS24008Msg_RqstSecondaryPDPCtxtAct (pctxt, pvalue->data.
            u.obj_RqstSecondaryPDPCtxtAct);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RqstSecondaryPDPCtxtActRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RqstSecondaryPDPCtxtActRej;

         pvalue->data.u.obj_RqstSecondaryPDPCtxtActRej
             = rtxMemAllocType (pctxt, TS24008Msg_RqstSecondaryPDPCtxtActRej);

         if (pvalue->data.u.obj_RqstSecondaryPDPCtxtActRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RqstSecondaryPDPCtxtActRej (pvalue->data.
            u.obj_RqstSecondaryPDPCtxtActRej);

         ret = NASDec_TS24008Msg_RqstSecondaryPDPCtxtActRej (pctxt, pvalue->
            data.u.obj_RqstSecondaryPDPCtxtActRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_SMStatus:
         pvalue->data.t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_SMStatus;

         ret = NASDec_TS24008IE_SMCauseValue (pctxt, &pvalue->data.
            u.obj_SMStatus);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateMBMSCtxtReq:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateMBMSCtxtReq;

         pvalue->data.u.obj_ActivateMBMSCtxtReq = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateMBMSCtxtReq);

         if (pvalue->data.u.obj_ActivateMBMSCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateMBMSCtxtReq (pvalue->data.
            u.obj_ActivateMBMSCtxtReq);

         ret = NASDec_TS24008Msg_ActivateMBMSCtxtReq (pctxt, pvalue->data.
            u.obj_ActivateMBMSCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateMBMSCtxtAcc:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateMBMSCtxtAcc;

         pvalue->data.u.obj_ActivateMBMSCtxtAcc = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateMBMSCtxtAcc);

         if (pvalue->data.u.obj_ActivateMBMSCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateMBMSCtxtAcc (pvalue->data.
            u.obj_ActivateMBMSCtxtAcc);

         ret = NASDec_TS24008Msg_ActivateMBMSCtxtAcc (pctxt, pvalue->data.
            u.obj_ActivateMBMSCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_ActivateMBMSCtxtRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_ActivateMBMSCtxtRej;

         pvalue->data.u.obj_ActivateMBMSCtxtRej = rtxMemAllocType (pctxt, 
            TS24008Msg_ActivateMBMSCtxtRej);

         if (pvalue->data.u.obj_ActivateMBMSCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_ActivateMBMSCtxtRej (pvalue->data.
            u.obj_ActivateMBMSCtxtRej);

         ret = NASDec_TS24008Msg_ActivateMBMSCtxtRej (pctxt, pvalue->data.
            u.obj_ActivateMBMSCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RequestMBMSCtxtAct:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RequestMBMSCtxtAct;

         pvalue->data.u.obj_RequestMBMSCtxtAct = rtxMemAllocType (pctxt, 
            TS24008Msg_RequestMBMSCtxtAct);

         if (pvalue->data.u.obj_RequestMBMSCtxtAct == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RequestMBMSCtxtAct (pvalue->data.
            u.obj_RequestMBMSCtxtAct);

         ret = NASDec_TS24008Msg_RequestMBMSCtxtAct (pctxt, pvalue->data.
            u.obj_RequestMBMSCtxtAct);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_mt_RequestMBMSCtxtActRej:
         pvalue->data.
            t = T_TS24008Msgs_TS24008_IE_OBJECTSET_obj_RequestMBMSCtxtActRej;

         pvalue->data.u.obj_RequestMBMSCtxtActRej = rtxMemAllocType (pctxt, 
            TS24008Msg_RequestMBMSCtxtActRej);

         if (pvalue->data.u.obj_RequestMBMSCtxtActRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24008Msg_RequestMBMSCtxtActRej (pvalue->data.
            u.obj_RequestMBMSCtxtActRej);

         ret = NASDec_TS24008Msg_RequestMBMSCtxtActRej (pctxt, pvalue->data.
            u.obj_RequestMBMSCtxtActRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   default:
      return RTERR_INVOPT;
   }

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

