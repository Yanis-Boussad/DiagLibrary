/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.2-pre4, Date: 04-Apr-2013.
 */
#include "TS24301Msgs.h"
#include "rtxsrc/rtxCommon.h"
#include "rtxsrc/rtxBitDecode.h"
#include "rtxsrc/rtxIntDecode.h"
#include "rtxsrc/rtx3GPP.h"
#include "rtxsrc/rtxDiagBitTrace.h"

EXTERN int NASDec_TS24301Msg_AttachComplete (OSCTXT* pctxt
   , TS24301Msg_AttachComplete* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachComplete");

   ret = NASDec_TS24301IE_ESMMessageContainer (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AuthResponse (OSCTXT* pctxt
   , TS24301Msg_AuthResponse* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthResponse");

   ret = NASDec_TS24301IE_AuthRespParam (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DLNASTransport (OSCTXT* pctxt
   , TS24301Msg_DLNASTransport* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLNASTransport");

   ret = NASDec_TS24301IE_NASMessageContainer (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_EMMStatus (OSCTXT* pctxt
   , TS24301Msg_EMMStatus* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EMMStatus");

   ret = NASDec_TS24301IE_EMMCause (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_IdentResp (OSCTXT* pctxt
   , TS24301Msg_IdentResp* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentResp");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_SecModeReject (OSCTXT* pctxt
   , TS24301Msg_SecModeReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeReject");

   ret = NASDec_TS24301IE_EMMCause (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ULNASTransport (OSCTXT* pctxt
   , TS24301Msg_ULNASTransport* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULNASTransport");

   ret = NASDec_TS24301IE_NASMessageContainer (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_GenNASTransport_addnInfo (OSCTXT* pctxt
   , TS24301Msg_GenNASTransport_addnInfo* pvalue)
{
   int ret = 0;

   /* Decode OCTET STRING value */
   RTDIAG_NEWBITFIELD (pctxt, "OCTET STRING");

   ret = rtxDecBitsToByte (pctxt, &pvalue->numocts, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   ret = rtxReadBytes (pctxt, pvalue->data, pvalue->numocts);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   if (!(pvalue->numocts <= 253)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->numocts);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTDIAG_SETBITFLDCOUNT (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_GenNASTransport (OSCTXT* pctxt
   , TS24301Msg_GenNASTransport* pvalue)
{
   OSBOOL present;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GenNASTransport");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode genMsgContainerType */

   RTXCTXTPUSHELEMNAME (pctxt, "genMsgContainerType");

   ret = NASDec_TS24301IE_GenMsgContainerType (pctxt, &pvalue->
      genMsgContainerType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode genMsgContainer */

   RTXCTXTPUSHELEMNAME (pctxt, "genMsgContainer");

   ret = NASDec_TS24301IE_GenMessageContainer (pctxt, &pvalue->genMsgContainer
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode addnInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "addnInfo");
   RTDIAG_NEWBITFIELD (pctxt, "optional bit");

   ret = rtxDecBit (pctxt, &present);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   if (present) {
      ret = NASDec_TS24301Msg_GenNASTransport_addnInfo (pctxt, &pvalue->
         addnInfo);
      if (ret < 0) return LOG_RTERR (pctxt, ret);
      pvalue->m.addnInfoPresent = 1;
   }
   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DLGenNASTransport (OSCTXT* pctxt
   , TS24301Msg_DLGenNASTransport* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DLGenNASTransport");

   ret = NASDec_TS24301Msg_GenNASTransport (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ULGenNASTransport (OSCTXT* pctxt
   , TS24301Msg_ULGenNASTransport* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ULGenNASTransport");

   ret = NASDec_TS24301Msg_GenNASTransport (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ESMStatus (OSCTXT* pctxt
   , TS24301Msg_ESMStatus* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ESMStatus");

   ret = NASDec_TS24301IE_ESMCause (pctxt, pvalue);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AttachAccept (OSCTXT* pctxt
   , TS24301Msg_AttachAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode result */

   RTXCTXTPUSHELEMNAME (pctxt, "result");

   ret = NASDec_TS24301IE_EPSAttachResult (pctxt, &pvalue->result);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode t3412Value */

   RTXCTXTPUSHELEMNAME (pctxt, "t3412Value");

   ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3412Value);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode taiList */

   RTXCTXTPUSHELEMNAME (pctxt, "taiList");

   ret = NASDec_TS24301IE_TrackingAreaIdentList (pctxt, &pvalue->taiList);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode esmMessageContainer */

   RTXCTXTPUSHELEMNAME (pctxt, "esmMessageContainer");

   ret = NASDec_TS24301IE_ESMMessageContainer (pctxt, &pvalue->
      esmMessageContainer);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 80: {
               if (lastRow == 0) {
                  /* decode guti */
                  RTXCTXTPUSHELEMNAME (pctxt, "guti");

                  ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->
                     guti);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gutiPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 19: {
               if (lastRow <= 1) {
                  /* decode locAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->
                     locAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.locAreaIdentPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 35: {
               if (lastRow <= 2) {
                  /* decode msIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "msIdentity");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     msIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msIdentityPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 83: {
               if (lastRow <= 3) {
                  /* decode emmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

                  ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emmCausePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 23: {
               if (lastRow <= 4) {
                  /* decode t3402 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3402");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3402);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3402Present = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 89: {
               if (lastRow <= 5) {
                  /* decode t3423 */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3423");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3423);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3423Present = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 74: {
               if (lastRow <= 6) {
                  /* decode equivPLMNs */
                  RTXCTXTPUSHELEMNAME (pctxt, "equivPLMNs");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->equivPLMNs
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.equivPLMNsPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 7) {
                  /* decode emergNumList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergNumList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergNumList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergNumListPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 100: {
               if (lastRow <= 8) {
                  /* decode epsNetFeatSupp */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsNetFeatSupp");

                  ret = NASDec_TS24301IE_EPSNetworkFeatureSupport (pctxt, &
                     pvalue->epsNetFeatSupp);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsNetFeatSuppPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 9) {
                  /* decode addnUpdateResult */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateResult");

                  ret = NASDec_TS24301IE_AddnUpdateResult (pctxt, &pvalue->
                     addnUpdateResult);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateResultPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 94: {
               if (lastRow <= 10) {
                  /* decode t3412ExtValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3412ExtValue");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     t3412ExtValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3412ExtValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AttachReject (OSCTXT* pctxt
   , TS24301Msg_AttachReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode emmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

   ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 120: {
               if (lastRow == 0) {
                  /* decode esmMsgCont */
                  RTXCTXTPUSHELEMNAME (pctxt, "esmMsgCont");

                  ret = NASDec_TS24301IE_ESMMessageContainer (pctxt, &pvalue->
                     esmMsgCont);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.esmMsgContPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 95: {
               if (lastRow <= 1) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 22: {
               if (lastRow <= 2) {
                  /* decode t3402Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3402Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3402Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3402ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AttachRequest (OSCTXT* pctxt
   , TS24301Msg_AttachRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttachRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasKeySetIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdentifier");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
      nasKeySetIdentifier);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode epsAttachType */

   RTXCTXTPUSHELEMNAME (pctxt, "epsAttachType");

   ret = NASDec_TS24301IE_EPSAttachType (pctxt, &pvalue->epsAttachType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode oldGUTIOrIMSI */

   RTXCTXTPUSHELEMNAME (pctxt, "oldGUTIOrIMSI");

   ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->oldGUTIOrIMSI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ueNetworkCapability */

   RTXCTXTPUSHELEMNAME (pctxt, "ueNetworkCapability");

   ret = NASDec_TS24301IE_UENetworkCapability (pctxt, &pvalue->
      ueNetworkCapability);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode esmMessageContainer */

   RTXCTXTPUSHELEMNAME (pctxt, "esmMessageContainer");

   ret = NASDec_TS24301IE_ESMMessageContainer (pctxt, &pvalue->
      esmMessageContainer);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 9 || nibble == 15 || nibble == 13 || nibble == 14 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 25: {
               if (lastRow == 0) {
                  /* decode oldP-TMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldP-TMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     oldP_TMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldP_TMSISignaturePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 80: {
               if (lastRow <= 1) {
                  /* decode additionalGUTI */
                  RTXCTXTPUSHELEMNAME (pctxt, "additionalGUTI");

                  ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->
                     additionalGUTI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.additionalGUTIPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 82: {
               if (lastRow <= 2) {
                  /* decode lastVisitedRegisteredTAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "lastVisitedRegisteredTAI");

                  ret = NASDec_TS24301IE_TrackingAreaIdent (pctxt, &pvalue->
                     lastVisitedRegisteredTAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lastVisitedRegisteredTAIPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 92: {
               if (lastRow <= 3) {
                  /* decode drxParameter */
                  RTXCTXTPUSHELEMNAME (pctxt, "drxParameter");

                  ret = NASDec_TS24008IE_DRXParameter (pctxt, &pvalue->
                     drxParameter);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.drxParameterPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 49: {
               if (lastRow <= 4) {
                  /* decode msNetworkCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetworkCapability");

                  ret = NASDec_TS24008IE_MSNetworkCapability (pctxt, &pvalue->
                     msNetworkCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetworkCapabilityPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 19: {
               if (lastRow <= 5) {
                  /* decode oldLocAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldLocAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->
                     oldLocAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldLocAreaIdentPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 9: {
               if (lastRow <= 6) {
                  /* decode tmsiStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiStatus");

                  ret = NASDec_TS24008IE_TMSIStatus (pctxt, &pvalue->tmsiStatus
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiStatusPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 17: {
               if (lastRow <= 7) {
                  /* decode mobileStationClassmark2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark2");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->mobileStationClassmark2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileStationClassmark2Present = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 32: {
               if (lastRow <= 8) {
                  /* decode mobileStationClassmark3 */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark3");

                  ret = NASDec_TS24008IE_MobileStationClassmark3 (pctxt, &
                     pvalue->mobileStationClassmark3);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileStationClassmark3Present = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 9) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 10) {
                  /* decode addnUpdateType */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateType");

                  ret = NASDec_TS24301IE_AddnUpdateType (pctxt, &pvalue->
                     addnUpdateType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateTypePresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 93: {
               if (lastRow <= 11) {
                  /* decode voiceDomainPref */
                  RTXCTXTPUSHELEMNAME (pctxt, "voiceDomainPref");

                  ret = NASDec_TS24008IE_VoiceDomainPref (pctxt, &pvalue->
                     voiceDomainPref);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.voiceDomainPrefPresent = 1;
                  pvalue->m._v9ExtPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 13: {
               if (lastRow <= 12) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 14: {
               if (lastRow <= 13) {
                  /* decode oldGUTIType */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldGUTIType");

                  ret = NASDec_TS24301IE_GUTIType (pctxt, &pvalue->oldGUTIType
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldGUTITypePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 14) {
                  /* decode msNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetFeatureSupport");

                  ret = NASDec_TS24008IE_MSNetFeatureSupport (pctxt, &pvalue->
                     msNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetFeatureSupportPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 16: {
               if (lastRow <= 15) {
                  /* decode tmsiBasedNRIContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiBasedNRIContainer");

                  ret = NASDec_TS24008IE_NetResourceIdentContainer (pctxt, &
                     pvalue->tmsiBasedNRIContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiBasedNRIContainerPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AuthFailure (OSCTXT* pctxt
   , TS24301Msg_AuthFailure* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthFailure");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode emmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

   ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 48: {
               if (lastRow == 0) {
                  /* decode authFailureParam */
                  RTXCTXTPUSHELEMNAME (pctxt, "authFailureParam");

                  ret = NASDec_TS24008IE_AuthFailureParam (pctxt, &pvalue->
                     authFailureParam);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.authFailureParamPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_AuthRequest (OSCTXT* pctxt
   , TS24301Msg_AuthRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthRequest");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode authParamRAND */

   RTXCTXTPUSHELEMNAME (pctxt, "authParamRAND");

   ret = NASDec_TS24008IE_AuthParamRAND (pctxt, &pvalue->authParamRAND);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode authParamAUTN */

   RTXCTXTPUSHELEMNAME (pctxt, "authParamAUTN");

   ret = NASDec_TS24008IE_AuthParamAUTN (pctxt, &pvalue->authParamAUTN);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_CSServiceNotif (OSCTXT* pctxt
   , TS24301Msg_CSServiceNotif* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CSServiceNotif");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode pagingIdentity */

   RTXCTXTPUSHELEMNAME (pctxt, "pagingIdentity");

   ret = NASDec_TS24301IE_PagingIdentity (pctxt, &pvalue->pagingIdentity);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 96: {
               if (lastRow == 0) {
                  /* decode cli */
                  RTXCTXTPUSHELEMNAME (pctxt, "cli");

                  ret = NASDec_TS24301IE_CLI (pctxt, &pvalue->cli);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.cliPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 97: {
               if (lastRow <= 1) {
                  /* decode ssCode */
                  RTXCTXTPUSHELEMNAME (pctxt, "ssCode");

                  ret = NASDec_TS24301IE_SSCode (pctxt, &pvalue->ssCode);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ssCodePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 98: {
               if (lastRow <= 2) {
                  /* decode lcsIndicator */
                  RTXCTXTPUSHELEMNAME (pctxt, "lcsIndicator");

                  ret = NASDec_TS24301IE_LCSIndicator (pctxt, &pvalue->
                     lcsIndicator);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lcsIndicatorPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 99: {
               if (lastRow <= 3) {
                  /* decode lcsClientIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "lcsClientIdentity");

                  ret = NASDec_TS24301IE_LCSClientIdentity (pctxt, &pvalue->
                     lcsClientIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lcsClientIdentityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DetachRequestUEOrig (OSCTXT* pctxt
   , TS24301Msg_DetachRequestUEOrig* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DetachRequestUEOrig");

   /* decode nasKeySetIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdent");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->nasKeySetIdent
      );
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode detachType */

   RTXCTXTPUSHELEMNAME (pctxt, "detachType");

   ret = NASDec_TS24301IE_DetachType (pctxt, &pvalue->detachType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode gUTIOrIMSI */

   RTXCTXTPUSHELEMNAME (pctxt, "gUTIOrIMSI");

   ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->gUTIOrIMSI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DetachRequestUETerm (OSCTXT* pctxt
   , TS24301Msg_DetachRequestUETerm* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DetachRequestUETerm");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode detachType */

   RTXCTXTPUSHELEMNAME (pctxt, "detachType");

   ret = NASDec_TS24301IE_DetachType (pctxt, &pvalue->detachType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode emmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

   ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

/* begin custom source file TS24301MsgDec_DetachRequest.c */

EXTERN int NASDec_TS24301Msg_DetachRequest (OSCTXT* pctxt
   , TS24301Msg_DetachRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DetachRequest");

   /* The OS3GMOBORIG flag is checked in the context to determine if 
      this is a mobile-originated message.  The user must set this 
      explicitly before calling the decode PDU function. */

   pvalue->t = (rtxCtxtTestFlag (pctxt, OS3GMOBORIG)) ?
      1 /* UE (mobile) originated */ : 2 /* network originated */ ;

   /* Decode choice data value */

   switch (pvalue->t)
   {
      /* ueOrig */
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "ueOrig");

         ret = NASDec_TS24301Msg_DetachRequestUEOrig (pctxt, &pvalue->u.ueOrig
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* ueTerm */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ueTerm");

         ret = NASDec_TS24301Msg_DetachRequestUETerm (pctxt, &pvalue->u.ueTerm
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

/* end custom source file TS24301MsgDec_DetachRequest.c */

EXTERN int NASDec_TS24301Msg_EMMInformation (OSCTXT* pctxt
   , TS24301Msg_EMMInformation* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EMMInformation");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 67: {
               if (lastRow == 0) {
                  /* decode fullNameForNetwork */
                  RTXCTXTPUSHELEMNAME (pctxt, "fullNameForNetwork");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     fullNameForNetwork);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.fullNameForNetworkPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 69: {
               if (lastRow <= 1) {
                  /* decode shortNameForNetwork */
                  RTXCTXTPUSHELEMNAME (pctxt, "shortNameForNetwork");

                  ret = NASDec_TS24008IE_NetworkName (pctxt, &pvalue->
                     shortNameForNetwork);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.shortNameForNetworkPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 70: {
               if (lastRow <= 2) {
                  /* decode localTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "localTimeZone");

                  ret = NASDec_TS24008IE_TimeZone (pctxt, &pvalue->
                     localTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.localTimeZonePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 71: {
               if (lastRow <= 3) {
                  /* decode univTimeAndLclTimeZone */
                  RTXCTXTPUSHELEMNAME (pctxt, "univTimeAndLclTimeZone");

                  ret = NASDec_TS24008IE_TimeZoneAndTime (pctxt, &pvalue->
                     univTimeAndLclTimeZone);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.univTimeAndLclTimeZonePresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 7;
               }
               break;
            }
            case 73: {
               if (lastRow <= 4) {
                  /* decode networkDaylightSavingTime */
                  RTXCTXTPUSHELEMNAME (pctxt, "networkDaylightSavingTime");

                  ret = NASDec_TS24008IE_DaylightSavingTime (pctxt, &pvalue->
                     networkDaylightSavingTime);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.networkDaylightSavingTimePresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ExtServiceReq (OSCTXT* pctxt
   , TS24301Msg_ExtServiceReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtServiceReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasKeySetIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdentifier");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
      nasKeySetIdentifier);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode serviceType */

   RTXCTXTPUSHELEMNAME (pctxt, "serviceType");

   ret = NASDec_TS24301IE_ServiceType (pctxt, &pvalue->serviceType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode m-tmsi */

   RTXCTXTPUSHELEMNAME (pctxt, "m-tmsi");

   ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->m_tmsi);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11 || nibble == 13) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 11: {
               if (lastRow == 0) {
                  /* decode csfbResponse */
                  RTXCTXTPUSHELEMNAME (pctxt, "csfbResponse");

                  ret = NASDec_TS24301IE_CSFBResponse (pctxt, &pvalue->
                     csfbResponse);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.csfbResponsePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 1) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_GUTIReallocCmd (OSCTXT* pctxt
   , TS24301Msg_GUTIReallocCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GUTIReallocCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode guti */

   RTXCTXTPUSHELEMNAME (pctxt, "guti");

   ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->guti);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 84: {
               if (lastRow == 0) {
                  /* decode taiList */
                  RTXCTXTPUSHELEMNAME (pctxt, "taiList");

                  ret = NASDec_TS24301IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->taiList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.taiListPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_IdentReq (OSCTXT* pctxt
   , TS24301Msg_IdentReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IdentReq");

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode identType */

   RTXCTXTPUSHELEMNAME (pctxt, "identType");

   ret = NASDec_TS24008IE_IdentityType2Value (pctxt, &pvalue->identType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   ret = rtx3GPPDecL3NonImperative (pctxt, FALSE);
   if (0 != ret) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_SecModeCmd (OSCTXT* pctxt
   , TS24301Msg_SecModeCmd* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeCmd");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode selNASSecurityAlgs */

   RTXCTXTPUSHELEMNAME (pctxt, "selNASSecurityAlgs");

   ret = NASDec_TS24301IE_NASSecurityAlgorithms (pctxt, &pvalue->
      selNASSecurityAlgs);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode nasKeySetIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdentifier");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
      nasKeySetIdentifier);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode replayedUESecurityCapabilities */

   RTXCTXTPUSHELEMNAME (pctxt, "replayedUESecurityCapabilities");

   ret = NASDec_TS24301IE_UESecurityCapability (pctxt, &pvalue->
      replayedUESecurityCapabilities);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 12: {
               if (lastRow == 0) {
                  /* decode imeisvRequest */
                  RTXCTXTPUSHELEMNAME (pctxt, "imeisvRequest");

                  ret = NASDec_TS24008IE_IMEISVRequest (pctxt, &pvalue->
                     imeisvRequest);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.imeisvRequestPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 85: {
               if (lastRow <= 1) {
                  /* decode replayedNonce */
                  RTXCTXTPUSHELEMNAME (pctxt, "replayedNonce");

                  ret = NASDec_TS24301IE_Nonce (pctxt, &pvalue->replayedNonce
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.replayedNoncePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 4;
               }
               break;
            }
            case 86: {
               if (lastRow <= 2) {
                  /* decode nonce */
                  RTXCTXTPUSHELEMNAME (pctxt, "nonce");

                  ret = NASDec_TS24301IE_Nonce (pctxt, &pvalue->nonce);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.noncePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 4;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_SecModeCmplt (OSCTXT* pctxt
   , TS24301Msg_SecModeCmplt* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecModeCmplt");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 35: {
               if (lastRow == 0) {
                  /* decode imeisv */
                  RTXCTXTPUSHELEMNAME (pctxt, "imeisv");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->imeisv
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.imeisvPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ServiceReject (OSCTXT* pctxt
   , TS24301Msg_ServiceReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode emmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

   ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 91: {
               if (lastRow == 0) {
                  /* decode t3442Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3442Value");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3442Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3442ValuePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 95: {
               if (lastRow <= 1) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_TrkAreaUpdAccept (OSCTXT* pctxt
   , TS24301Msg_TrkAreaUpdAccept* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrkAreaUpdAccept");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode epsUpdateResult */

   RTXCTXTPUSHELEMNAME (pctxt, "epsUpdateResult");

   ret = NASDec_TS24301IE_EPSUpdateResult (pctxt, &pvalue->epsUpdateResult);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 15) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 90: {
               if (lastRow == 0) {
                  /* decode t3412Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3412Value");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3412Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3412ValuePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 80: {
               if (lastRow <= 1) {
                  /* decode guti */
                  RTXCTXTPUSHELEMNAME (pctxt, "guti");

                  ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->
                     guti);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gutiPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 84: {
               if (lastRow <= 2) {
                  /* decode taiList */
                  RTXCTXTPUSHELEMNAME (pctxt, "taiList");

                  ret = NASDec_TS24301IE_TrackingAreaIdentList (pctxt, &pvalue
                     ->taiList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.taiListPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 87: {
               if (lastRow <= 3) {
                  /* decode epsBearerContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerContextStatus");

                  ret = NASDec_TS24301IE_EPSBearerContextStatus (pctxt, &pvalue
                     ->epsBearerContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerContextStatusPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 19: {
               if (lastRow <= 4) {
                  /* decode locAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "locAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->
                     locAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.locAreaIdentPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 35: {
               if (lastRow <= 5) {
                  /* decode msIdentity */
                  RTXCTXTPUSHELEMNAME (pctxt, "msIdentity");

                  ret = NASDec_TS24008IE_MobileIdentity (pctxt, &pvalue->
                     msIdentity);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msIdentityPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 83: {
               if (lastRow <= 6) {
                  /* decode emmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "emmCause");

                  ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->emmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emmCausePresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 23: {
               if (lastRow <= 7) {
                  /* decode t3402Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3402Value");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3402Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3402ValuePresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 89: {
               if (lastRow <= 8) {
                  /* decode t3423Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3423Value");

                  ret = NASDec_TS24008IE_GPRSTimer (pctxt, &pvalue->t3423Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3423ValuePresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 74: {
               if (lastRow <= 9) {
                  /* decode equivalentPLMNs */
                  RTXCTXTPUSHELEMNAME (pctxt, "equivalentPLMNs");

                  ret = NASDec_TS24008IE_PLMNList (pctxt, &pvalue->
                     equivalentPLMNs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.equivalentPLMNsPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 52: {
               if (lastRow <= 10) {
                  /* decode emergencyNumberList */
                  RTXCTXTPUSHELEMNAME (pctxt, "emergencyNumberList");

                  ret = NASDec_TS24008IE_EmergencyNumberList (pctxt, &pvalue->
                     emergencyNumberList);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.emergencyNumberListPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 100: {
               if (lastRow <= 11) {
                  /* decode epsNetworkFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsNetworkFeatureSupport");

                  ret = NASDec_TS24301IE_EPSNetworkFeatureSupport (pctxt, &
                     pvalue->epsNetworkFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsNetworkFeatureSupportPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 12) {
                  /* decode addnUpdateResult */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateResult");

                  ret = NASDec_TS24301IE_AddnUpdateResult (pctxt, &pvalue->
                     addnUpdateResult);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateResultPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 94: {
               if (lastRow <= 13) {
                  /* decode t3412ExtValue */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3412ExtValue");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->
                     t3412ExtValue);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3412ExtValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_TrkAreaUpdReject (OSCTXT* pctxt
   , TS24301Msg_TrkAreaUpdReject* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrkAreaUpdReject");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode cause */

   RTXCTXTPUSHELEMNAME (pctxt, "cause");

   ret = NASDec_TS24301IE_EMMCause (pctxt, &pvalue->cause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 95: {
               if (lastRow == 0) {
                  /* decode t3346Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3346Value");

                  ret = NASDec_TS24008IE_GPRSTimer2 (pctxt, &pvalue->t3346Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3346ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_TrkAreaUpdRequest (OSCTXT* pctxt
   , TS24301Msg_TrkAreaUpdRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TrkAreaUpdRequest");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode nasKeySetIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "nasKeySetIdentifier");

   ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
      nasKeySetIdentifier);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode epsUpdateType */

   RTXCTXTPUSHELEMNAME (pctxt, "epsUpdateType");

   ret = NASDec_TS24301IE_EPSUpdateType (pctxt, &pvalue->epsUpdateType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode oldGUTI */

   RTXCTXTPUSHELEMNAME (pctxt, "oldGUTI");

   ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->oldGUTI);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 11 || nibble == 8 || nibble == 10 || nibble == 9 || nibble == 15 || nibble == 14 || nibble == 13 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 11: {
               if (lastRow == 0) {
                  /* decode nonCurrNativeNASKeySetIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "nonCurrNativeNASKeySetIdent");

                  ret = NASDec_TS24301IE_NASKeySetIdentifier (pctxt, &pvalue->
                     nonCurrNativeNASKeySetIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.nonCurrNativeNASKeySetIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 8: {
               if (lastRow <= 1) {
                  /* decode gprsCiphKeySeqNum */
                  RTXCTXTPUSHELEMNAME (pctxt, "gprsCiphKeySeqNum");

                  ret = NASDec_TS24008IE_CiphKeySeqNum (pctxt, &pvalue->
                     gprsCiphKeySeqNum);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.gprsCiphKeySeqNumPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 25: {
               if (lastRow <= 2) {
                  /* decode oldP-TMSISignature */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldP-TMSISignature");

                  ret = NASDec_TS24008IE_P_TMSISignature (pctxt, &pvalue->
                     oldP_TMSISignature);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldP_TMSISignaturePresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 3;
               }
               break;
            }
            case 80: {
               if (lastRow <= 3) {
                  /* decode additionalGUTI */
                  RTXCTXTPUSHELEMNAME (pctxt, "additionalGUTI");

                  ret = NASDec_TS24301IE_EPSMobileIdentity (pctxt, &pvalue->
                     additionalGUTI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.additionalGUTIPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 85: {
               if (lastRow <= 4) {
                  /* decode nonce */
                  RTXCTXTPUSHELEMNAME (pctxt, "nonce");

                  ret = NASDec_TS24301IE_Nonce (pctxt, &pvalue->nonce);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.noncePresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 4;
               }
               break;
            }
            case 88: {
               if (lastRow <= 5) {
                  /* decode ueNetworkCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueNetworkCapability");

                  ret = NASDec_TS24301IE_UENetworkCapability (pctxt, &pvalue->
                     ueNetworkCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueNetworkCapabilityPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 82: {
               if (lastRow <= 6) {
                  /* decode lastVisitedRegisteredTAI */
                  RTXCTXTPUSHELEMNAME (pctxt, "lastVisitedRegisteredTAI");

                  ret = NASDec_TS24301IE_TrackingAreaIdent (pctxt, &pvalue->
                     lastVisitedRegisteredTAI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.lastVisitedRegisteredTAIPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 92: {
               if (lastRow <= 7) {
                  /* decode drxParameter */
                  RTXCTXTPUSHELEMNAME (pctxt, "drxParameter");

                  ret = NASDec_TS24008IE_DRXParameter (pctxt, &pvalue->
                     drxParameter);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.drxParameterPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 2;
               }
               break;
            }
            case 10: {
               if (lastRow <= 8) {
                  /* decode ueRadioCapInfoUpdateNeeded */
                  RTXCTXTPUSHELEMNAME (pctxt, "ueRadioCapInfoUpdateNeeded");

                  ret = NASDec_TS24301IE_UERadioCapInfoUpdateNeeded (pctxt, &
                     pvalue->ueRadioCapInfoUpdateNeeded);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.ueRadioCapInfoUpdateNeededPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 87: {
               if (lastRow <= 9) {
                  /* decode epsBearerContextStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "epsBearerContextStatus");

                  ret = NASDec_TS24301IE_EPSBearerContextStatus (pctxt, &pvalue
                     ->epsBearerContextStatus);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.epsBearerContextStatusPresent = 1;

                  lastRow = 10;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 49: {
               if (lastRow <= 10) {
                  /* decode msNetworkCapability */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetworkCapability");

                  ret = NASDec_TS24008IE_MSNetworkCapability (pctxt, &pvalue->
                     msNetworkCapability);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetworkCapabilityPresent = 1;

                  lastRow = 11;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 19: {
               if (lastRow <= 11) {
                  /* decode oldLocAreaIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldLocAreaIdent");

                  ret = NASDec_TS24008IE_LocAreaIdent (pctxt, &pvalue->
                     oldLocAreaIdent);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldLocAreaIdentPresent = 1;

                  lastRow = 12;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 5;
               }
               break;
            }
            case 9: {
               if (lastRow <= 12) {
                  /* decode tmsiStatus */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiStatus");

                  ret = NASDec_TS24008IE_TMSIStatus (pctxt, &pvalue->tmsiStatus
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiStatusPresent = 1;

                  lastRow = 13;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 17: {
               if (lastRow <= 13) {
                  /* decode mobileStationClassmark2 */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark2");

                  ret = NASDec_TS24008IE_MobileStationClassmark2 (pctxt, &
                     pvalue->mobileStationClassmark2);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileStationClassmark2Present = 1;

                  lastRow = 14;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 32: {
               if (lastRow <= 14) {
                  /* decode mobileStationClassmark3 */
                  RTXCTXTPUSHELEMNAME (pctxt, "mobileStationClassmark3");

                  ret = NASDec_TS24008IE_MobileStationClassmark3 (pctxt, &
                     pvalue->mobileStationClassmark3);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.mobileStationClassmark3Present = 1;

                  lastRow = 15;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 64: {
               if (lastRow <= 15) {
                  /* decode supportedCodecs */
                  RTXCTXTPUSHELEMNAME (pctxt, "supportedCodecs");

                  ret = NASDec_TS24008IE_SupportedCodecList (pctxt, &pvalue->
                     supportedCodecs);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.supportedCodecsPresent = 1;

                  lastRow = 16;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 15: {
               if (lastRow <= 16) {
                  /* decode addnUpdateType */
                  RTXCTXTPUSHELEMNAME (pctxt, "addnUpdateType");

                  ret = NASDec_TS24301IE_AddnUpdateType (pctxt, &pvalue->
                     addnUpdateType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.addnUpdateTypePresent = 1;

                  lastRow = 17;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 93: {
               if (lastRow <= 17) {
                  /* decode voiceDomainPref */
                  RTXCTXTPUSHELEMNAME (pctxt, "voiceDomainPref");

                  ret = NASDec_TS24008IE_VoiceDomainPref (pctxt, &pvalue->
                     voiceDomainPref);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.voiceDomainPrefPresent = 1;
                  pvalue->m._v9ExtPresent = 1;

                  lastRow = 18;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 14: {
               if (lastRow <= 18) {
                  /* decode oldGUTIType */
                  RTXCTXTPUSHELEMNAME (pctxt, "oldGUTIType");

                  ret = NASDec_TS24301IE_GUTIType (pctxt, &pvalue->oldGUTIType
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.oldGUTITypePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 19;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 13: {
               if (lastRow <= 19) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 20;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 12: {
               if (lastRow <= 20) {
                  /* decode msNetFeatureSupport */
                  RTXCTXTPUSHELEMNAME (pctxt, "msNetFeatureSupport");

                  ret = NASDec_TS24008IE_MSNetFeatureSupport (pctxt, &pvalue->
                     msNetFeatureSupport);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.msNetFeatureSupportPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 21;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 16: {
               if (lastRow <= 21) {
                  /* decode tmsiBasedNRIContainer */
                  RTXCTXTPUSHELEMNAME (pctxt, "tmsiBasedNRIContainer");

                  ret = NASDec_TS24008IE_NetResourceIdentContainer (pctxt, &
                     pvalue->tmsiBasedNRIContainer);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tmsiBasedNRIContainerPresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 22;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDedEPSBearerCtxtAcc (OSCTXT* pctxt
   , TS24301Msg_ActvDedEPSBearerCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDedEPSBearerCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDedEPSBearerCtxtRej (OSCTXT* pctxt
   , TS24301Msg_ActvDedEPSBearerCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDedEPSBearerCtxtRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDedEPSBearerCtxtReq (OSCTXT* pctxt
   , TS24301Msg_ActvDedEPSBearerCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDedEPSBearerCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedEPSBearerIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedEPSBearerIdent");

   ret = NASDec_TS24301IE_LinkedEPSBearerIdent (pctxt, &pvalue->
      linkedEPSBearerIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode epsQoS */

   RTXCTXTPUSHELEMNAME (pctxt, "epsQoS");

   ret = NASDec_TS24301IE_EPSQualityOfService (pctxt, &pvalue->epsQoS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode tft */

   RTXCTXTPUSHELEMNAME (pctxt, "tft");

   ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->tft);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 93: {
               if (lastRow == 0) {
                  /* decode transIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "transIdent");

                  ret = NASDec_TS24008IE_LinkedTI (pctxt, &pvalue->transIdent
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.transIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 48: {
               if (lastRow <= 1) {
                  /* decode negotiatedQoS */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedQoS");

                  ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->
                     negotiatedQoS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedQoSPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 2) {
                  /* decode negotiatedLLCSAPI */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

                  ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->
                     negotiatedLLCSAPI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedLLCSAPIPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 3) {
                  /* decode radioPriority */
                  RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

                  ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->
                     radioPriority);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.radioPriorityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 4) {
                  /* decode packetFlowIdentifier */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdentifier");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdentifier);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentifierPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 5) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDfltEPSBearerCtxtAcc (OSCTXT* pctxt
   , TS24301Msg_ActvDfltEPSBearerCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDfltEPSBearerCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDfltEPSBearerCtxtRej (OSCTXT* pctxt
   , TS24301Msg_ActvDfltEPSBearerCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDfltEPSBearerCtxtRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ActvDfltEPSBearerCtxtReq (OSCTXT* pctxt
   , TS24301Msg_ActvDfltEPSBearerCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ActvDfltEPSBearerCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode epsQoS */

   RTXCTXTPUSHELEMNAME (pctxt, "epsQoS");

   ret = NASDec_TS24301IE_EPSQualityOfService (pctxt, &pvalue->epsQoS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode accessPointName */

   RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

   ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->accessPointName);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pdnAddress */

   RTXCTXTPUSHELEMNAME (pctxt, "pdnAddress");

   ret = NASDec_TS24301IE_PDNAddress (pctxt, &pvalue->pdnAddress);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8 || nibble == 11) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 93: {
               if (lastRow == 0) {
                  /* decode transIdent */
                  RTXCTXTPUSHELEMNAME (pctxt, "transIdent");

                  ret = NASDec_TS24008IE_LinkedTI (pctxt, &pvalue->transIdent
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.transIdentPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 48: {
               if (lastRow <= 1) {
                  /* decode negotiatedQoS */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedQoS");

                  ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->
                     negotiatedQoS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedQoSPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 2) {
                  /* decode negotiatedLLCSAPI */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

                  ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->
                     negotiatedLLCSAPI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedLLCSAPIPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 3) {
                  /* decode radioPriority */
                  RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

                  ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->
                     radioPriority);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.radioPriorityPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 4) {
                  /* decode packetFlowIdentifier */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdentifier");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdentifier);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentifierPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 94: {
               if (lastRow <= 5) {
                  /* decode apn-AMBR */
                  RTXCTXTPUSHELEMNAME (pctxt, "apn-AMBR");

                  ret = NASDec_TS24301IE_APNAggMaxBitRate (pctxt, &pvalue->
                     apn_AMBR);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.apn_AMBRPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 88: {
               if (lastRow <= 6) {
                  /* decode esmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

                  ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.esmCausePresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 39: {
               if (lastRow <= 7) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 11: {
               if (lastRow <= 8) {
                  /* decode connectivityType */
                  RTXCTXTPUSHELEMNAME (pctxt, "connectivityType");

                  ret = NASDec_TS24008IE_ConnectivityType (pctxt, &pvalue->
                     connectivityType);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.connectivityTypePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 9;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_BearerResAllocRej (OSCTXT* pctxt
   , TS24301Msg_BearerResAllocRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BearerResAllocRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_BearerResAllocReq (OSCTXT* pctxt
   , TS24301Msg_BearerResAllocReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BearerResAllocReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedEPSBearerIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedEPSBearerIdent");

   ret = NASDec_TS24301IE_LinkedEPSBearerIdent (pctxt, &pvalue->
      linkedEPSBearerIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trafficFlowAgg */

   RTXCTXTPUSHELEMNAME (pctxt, "trafficFlowAgg");

   ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->trafficFlowAgg);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode epsQoS */

   RTXCTXTPUSHELEMNAME (pctxt, "epsQoS");

   ret = NASDec_TS24301IE_EPSQualityOfService (pctxt, &pvalue->epsQoS);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 1) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_BearerResModRej (OSCTXT* pctxt
   , TS24301Msg_BearerResModRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BearerResModRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_BearerResModReq (OSCTXT* pctxt
   , TS24301Msg_BearerResModReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BearerResModReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedEPSBearerIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedEPSBearerIdent");

   ret = NASDec_TS24301IE_LinkedEPSBearerIdent (pctxt, &pvalue->
      linkedEPSBearerIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode trafficFlowAgg */

   RTXCTXTPUSHELEMNAME (pctxt, "trafficFlowAgg");

   ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->trafficFlowAgg);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 91: {
               if (lastRow == 0) {
                  /* decode reqTrafficFlowQoS */
                  RTXCTXTPUSHELEMNAME (pctxt, "reqTrafficFlowQoS");

                  ret = NASDec_TS24301IE_EPSQualityOfService (pctxt, &pvalue->
                     reqTrafficFlowQoS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.reqTrafficFlowQoSPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 88: {
               if (lastRow <= 1) {
                  /* decode esmCause */
                  RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

                  ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.esmCausePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 39: {
               if (lastRow <= 2) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 3) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DeactEPSBearerCtxtAcc (OSCTXT* pctxt
   , TS24301Msg_DeactEPSBearerCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactEPSBearerCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_DeactEPSBearerCtxtReq (OSCTXT* pctxt
   , TS24301Msg_DeactEPSBearerCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DeactEPSBearerCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v11ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ESMInfoResp (OSCTXT* pctxt
   , TS24301Msg_ESMInfoResp* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ESMInfoResp");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 40: {
               if (lastRow == 0) {
                  /* decode accessPointName */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

                  ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->
                     accessPointName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessPointNamePresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 1) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ModEPSBearerCtxtAcc (OSCTXT* pctxt
   , TS24301Msg_ModEPSBearerCtxtAcc* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModEPSBearerCtxtAcc");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ModEPSBearerCtxtRej (OSCTXT* pctxt
   , TS24301Msg_ModEPSBearerCtxtRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModEPSBearerCtxtRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ModEPSBearerCtxtReq (OSCTXT* pctxt
   , TS24301Msg_ModEPSBearerCtxtReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ModEPSBearerCtxtReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 8) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 91: {
               if (lastRow == 0) {
                  /* decode newEPSQoS */
                  RTXCTXTPUSHELEMNAME (pctxt, "newEPSQoS");

                  ret = NASDec_TS24301IE_EPSQualityOfService (pctxt, &pvalue->
                     newEPSQoS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.newEPSQoSPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 54: {
               if (lastRow <= 1) {
                  /* decode tft */
                  RTXCTXTPUSHELEMNAME (pctxt, "tft");

                  ret = NASDec_TS24008IE_TFT (pctxt, &pvalue->tft);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.tftPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 48: {
               if (lastRow <= 2) {
                  /* decode newQoS */
                  RTXCTXTPUSHELEMNAME (pctxt, "newQoS");

                  ret = NASDec_TS24008IE_QualityOfService (pctxt, &pvalue->
                     newQoS);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.newQoSPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 50: {
               if (lastRow <= 3) {
                  /* decode negotiatedLLCSAPI */
                  RTXCTXTPUSHELEMNAME (pctxt, "negotiatedLLCSAPI");

                  ret = NASDec_TS24008IE_LLCSAPIValue (pctxt, &pvalue->
                     negotiatedLLCSAPI);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.negotiatedLLCSAPIPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 1;
               }
               break;
            }
            case 8: {
               if (lastRow <= 4) {
                  /* decode radioPriority */
                  RTXCTXTPUSHELEMNAME (pctxt, "radioPriority");

                  ret = NASDec_TS24008IE_RadioPriorityValue (pctxt, &pvalue->
                     radioPriority);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.radioPriorityPresent = 1;

                  lastRow = 5;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 52: {
               if (lastRow <= 5) {
                  /* decode packetFlowIdentifier */
                  RTXCTXTPUSHELEMNAME (pctxt, "packetFlowIdentifier");

                  ret = NASDec_TS24008IE_PacketFlowIdentValue (pctxt, &pvalue->
                     packetFlowIdentifier);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.packetFlowIdentifierPresent = 1;

                  lastRow = 6;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 94: {
               if (lastRow <= 6) {
                  /* decode apn-AMBR */
                  RTXCTXTPUSHELEMNAME (pctxt, "apn-AMBR");

                  ret = NASDec_TS24301IE_APNAggMaxBitRate (pctxt, &pvalue->
                     apn_AMBR);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.apn_AMBRPresent = 1;

                  lastRow = 7;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 7) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 8;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_PDNConnectRej (OSCTXT* pctxt
   , TS24301Msg_PDNConnectRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDNConnectRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 55: {
               if (lastRow <= 1) {
                  /* decode t3396Value */
                  RTXCTXTPUSHELEMNAME (pctxt, "t3396Value");

                  ret = NASDec_TS24008IE_GPRSTimer3 (pctxt, &pvalue->t3396Value
                     );
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.t3396ValuePresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_PDNConnectReq (OSCTXT* pctxt
   , TS24301Msg_PDNConnectReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDNConnectReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode pdnType */

   RTXCTXTPUSHELEMNAME (pctxt, "pdnType");

   ret = NASDec_TS24301IE_PDNType (pctxt, &pvalue->pdnType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode requestType */

   RTXCTXTPUSHELEMNAME (pctxt, "requestType");

   ret = NASDec_TS24008IE_RequestTypeValue (pctxt, &pvalue->requestType);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;
         OSBOOL knownTVType1 = FALSE;
         OSUINT8 nibble;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         nibble = iei >> 4;
         if (nibble == 13 || nibble == 12) {
            /* decode 4-bit IEI */
            pctxt->buffer.byteIndex--;

            ret = rtxDecBitsToByte (pctxt, &iei, 4);
            if (0 != ret) return LOG_RTERR (pctxt, ret);

            knownTVType1 = TRUE;
            RTDIAG_SETBITFLDCOUNT (pctxt);
         }
         switch (iei) {
            case 13: {
               if (lastRow == 0) {
                  /* decode esmInfoXferFlag */
                  RTXCTXTPUSHELEMNAME (pctxt, "esmInfoXferFlag");

                  ret = NASDec_TS24301IE_ESMInfoXferFlag (pctxt, &pvalue->
                     esmInfoXferFlag);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.esmInfoXferFlagPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            case 40: {
               if (lastRow <= 1) {
                  /* decode accessPointName */
                  RTXCTXTPUSHELEMNAME (pctxt, "accessPointName");

                  ret = NASDec_TS24008IE_AccessPointName (pctxt, pvalue->
                     accessPointName);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.accessPointNamePresent = 1;

                  lastRow = 2;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 39: {
               if (lastRow <= 2) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 3;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            case 12: {
               if (lastRow <= 3) {
                  /* decode deviceProperties */
                  RTXCTXTPUSHELEMNAME (pctxt, "deviceProperties");

                  ret = NASDec_TS24008IE_DeviceProperties (pctxt, &pvalue->
                     deviceProperties);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.devicePropertiesPresent = 1;
                  pvalue->m._v10ExtPresent = 1;

                  lastRow = 4;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  skipBytes = 0;
               }
               break;
            }
            default: {
               if (!knownTVType1) {
                  if (!(iei & 0x80)) {
                     ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                     if (0 != ret) return LOG_RTERR (pctxt, ret);

                     comprReqd = (OSBOOL)((iei & 0x0F) == 0);
                  }
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_PDNDisconnRej (OSCTXT* pctxt
   , TS24301Msg_PDNDisconnRej* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDNDisconnRej");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode esmCause */

   RTXCTXTPUSHELEMNAME (pctxt, "esmCause");

   ret = NASDec_TS24301IE_ESMCause (pctxt, &pvalue->esmCause);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_PDNDisconnReq (OSCTXT* pctxt
   , TS24301Msg_PDNDisconnReq* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDNDisconnReq");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode spare */

   RTXCTXTPUSHELEMNAME (pctxt, "spare");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->spare, 4);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode linkedEPSBearerIdent */

   RTXCTXTPUSHELEMNAME (pctxt, "linkedEPSBearerIdent");

   ret = NASDec_TS24301IE_LinkedEPSBearerIdent (pctxt, &pvalue->
      linkedEPSBearerIdent);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   {
      int lastRow = 0;
      OSUINT8 iei, lastIEI = 0;

      while (!OSRTENDOFBUF(pctxt)) {
         OSUINT8 skipBytes = 0;
         OSBOOL comprReqd = FALSE;

         /* Decode IEI */
         RTDIAG_NEWBITFIELD (pctxt, "IEI");

         ret = rtxDecBitsToByte (pctxt, &iei, 8);
         if (ret == RTERR_ENDOFBUF) break;
         else if (0 != ret) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         switch (iei) {
            case 39: {
               if (lastRow == 0) {
                  /* decode protocolConfigOptions */
                  RTXCTXTPUSHELEMNAME (pctxt, "protocolConfigOptions");

                  ret = NASDec_TS24008IE_ProtocolConfigOptions (pctxt, &pvalue
                     ->protocolConfigOptions);
                  if (ret < 0) return LOG_RTERR (pctxt, ret);
                  pvalue->m.protocolConfigOptionsPresent = 1;

                  lastRow = 1;

                  RTXCTXTPOPELEMNAME (pctxt);
               }
               else {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);
               }
               break;
            }
            default: {
               if (!(iei & 0x80)) {
                  ret = rtxDecBitsToByte (pctxt, &skipBytes, 8);
                  if (0 != ret) return LOG_RTERR (pctxt, ret);

                  comprReqd = (OSBOOL)((iei & 0x0F) == 0);
               }
            }
         }

         if (skipBytes != 0) {
            ret = rtxSkipBits (pctxt, skipBytes * 8);
            if (0 != ret) return LOG_RTERR (pctxt, ret);
         }

         if (comprReqd && iei != lastIEI) {
            rtxErrAddIntParm (pctxt, iei);
            LOG_RTERRNEW (pctxt, RTERR_UNKNOWNIE);
         }

         lastIEI = iei;
      }
   }
   ret = rtxErrGetStatus (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_PDU (OSCTXT* pctxt, TS24301Msg_PDU* pvalue)
{
   OSBOOL present;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDU");

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* decode secHdr */

   /* begin custom source file TS24301MsgDec_PDU_secHdr.c */

   /* start custom code */
   {
      OSRTBufSave savedBuf;
      OSOCTET ub, pd;
   
      rtxDiagSetBitFldDisabled (pctxt->pBitFldList, TRUE);
      OSRTBUFSAVE2 (pctxt, &savedBuf);
   
      /* decode security header type */
      ret = rtxDecBitsToByte (pctxt, &ub, 4);
      if (0 != ret) return LOG_RTERR (pctxt, ret);
   
      /* decode protocol discriminator */
      ret = rtxDecBitsToByte (pctxt, &pd, 4);
      if (ret < 0) return LOG_RTERR (pctxt, ret);
   
      OSRTBUFRESTORE2 (pctxt, &savedBuf);
      rtxDiagSetBitFldDisabled (pctxt->pBitFldList, FALSE);
   
      if (ub != 0 && pd == TS24007L3_ProtoDiscr_epsMobMgmt) {
         RTXCTXTPUSHELEMNAME (pctxt, "secHdr");
   
         ret = NASDec_TS24007L3_SecProtMsgHeader (pctxt, &pvalue->secHdr);
         if (ret < 0) return LOG_RTERR (pctxt, ret);
   
         pvalue->m.secHdrPresent = 1;
   
         RTXCTXTPOPELEMNAME (pctxt);
      }
   
      /* decoding ciphered messages is currently not supported */
      if (pvalue->secHdr.secHdrType == TS24007L3_SecHdrType_integProtAndCipher ||
          pvalue->secHdr.secHdrType == TS24007L3_SecHdrType_integProtAndCipherAndSecCtxt) {
         rtxErrAddStrParm (pctxt, "decode NAS ciphered message");
         return LOG_RTERR (pctxt, RTERR_NOTSUPP);
      }
   }
   /* end custom code */

   /* end custom source file TS24301MsgDec_PDU_secHdr.c */

   /* decode l3HdrOpts */

   RTXCTXTPUSHELEMNAME (pctxt, "l3HdrOpts");

   ret = NASDec_TS24007L3_L3HdrOptions (pctxt, &pvalue->l3HdrOpts);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24007L3_ProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode pti */

   RTXCTXTPUSHELEMNAME (pctxt, "pti");

   /* Decode choice data value */

   switch (pvalue->protoDiscr)
   {
      /* value */
      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "value");

         RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

         ret = rtxDecBitsToByte (pctxt, &pvalue->pti.u.value, 8);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         RTDIAG_SETBITFLDCOUNT (pctxt);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      /* noValue */
      default:
         RTXCTXTPUSHELEMNAME (pctxt, "noValue");

         RTXCTXTPOPELEMNAME (pctxt);
         break;

   }

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode msgType */

   RTXCTXTPUSHELEMNAME (pctxt, "msgType");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->msgType, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode data */

   RTXCTXTPUSHELEMNAME (pctxt, "data");

   switch (pvalue->protoDiscr) {
   case TS24007L3_ProtoDiscr_epsMobMgmt:
      switch (pvalue->msgType) {
      case ASN1V_ts24301Msg_mt_AttachAccept:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AttachAccept;

         pvalue->data.u.obj_AttachAccept = rtxMemAllocType (pctxt, 
            TS24301Msg_AttachAccept);

         if (pvalue->data.u.obj_AttachAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AttachAccept (pvalue->data.u.obj_AttachAccept);

         ret = NASDec_TS24301Msg_AttachAccept (pctxt, pvalue->data.
            u.obj_AttachAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AttachComplete:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AttachComplete;

         pvalue->data.u.obj_AttachComplete = rtxMemAllocType (pctxt, 
            TS24301Msg_AttachComplete);

         if (pvalue->data.u.obj_AttachComplete == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AttachComplete (pvalue->data.u.obj_AttachComplete
            );

         ret = NASDec_TS24301Msg_AttachComplete (pctxt, pvalue->data.
            u.obj_AttachComplete);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AttachReject:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AttachReject;

         pvalue->data.u.obj_AttachReject = rtxMemAllocType (pctxt, 
            TS24301Msg_AttachReject);

         if (pvalue->data.u.obj_AttachReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AttachReject (pvalue->data.u.obj_AttachReject);

         ret = NASDec_TS24301Msg_AttachReject (pctxt, pvalue->data.
            u.obj_AttachReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AttachRequest:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AttachRequest;

         pvalue->data.u.obj_AttachRequest = rtxMemAllocType (pctxt, 
            TS24301Msg_AttachRequest);

         if (pvalue->data.u.obj_AttachRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AttachRequest (pvalue->data.u.obj_AttachRequest);

         ret = NASDec_TS24301Msg_AttachRequest (pctxt, pvalue->data.
            u.obj_AttachRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AuthFailure:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AuthFailure;

         pvalue->data.u.obj_AuthFailure = rtxMemAllocType (pctxt, 
            TS24301Msg_AuthFailure);

         if (pvalue->data.u.obj_AuthFailure == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AuthFailure (pvalue->data.u.obj_AuthFailure);

         ret = NASDec_TS24301Msg_AuthFailure (pctxt, pvalue->data.
            u.obj_AuthFailure);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AuthReject:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AuthReject;

         break;

      case ASN1V_ts24301Msg_mt_AuthRequest:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AuthRequest;

         pvalue->data.u.obj_AuthRequest = rtxMemAllocType (pctxt, 
            TS24301Msg_AuthRequest);

         if (pvalue->data.u.obj_AuthRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AuthRequest (pvalue->data.u.obj_AuthRequest);

         ret = NASDec_TS24301Msg_AuthRequest (pctxt, pvalue->data.
            u.obj_AuthRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_AuthResponse:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_AuthResponse;

         pvalue->data.u.obj_AuthResponse = rtxMemAllocType (pctxt, 
            TS24301Msg_AuthResponse);

         if (pvalue->data.u.obj_AuthResponse == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_AuthResponse (pvalue->data.u.obj_AuthResponse);

         ret = NASDec_TS24301Msg_AuthResponse (pctxt, pvalue->data.
            u.obj_AuthResponse);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_CSServiceNotif:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_CSServiceNotif;

         pvalue->data.u.obj_CSServiceNotif = rtxMemAllocType (pctxt, 
            TS24301Msg_CSServiceNotif);

         if (pvalue->data.u.obj_CSServiceNotif == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_CSServiceNotif (pvalue->data.u.obj_CSServiceNotif
            );

         ret = NASDec_TS24301Msg_CSServiceNotif (pctxt, pvalue->data.
            u.obj_CSServiceNotif);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_DetachAccept:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DetachAccept;

         break;

      case ASN1V_ts24301Msg_mt_DetachRequest:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DetachRequest;

         pvalue->data.u.obj_DetachRequest = rtxMemAllocType (pctxt, 
            TS24301Msg_DetachRequest);

         if (pvalue->data.u.obj_DetachRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_DetachRequest (pvalue->data.u.obj_DetachRequest);

         ret = NASDec_TS24301Msg_DetachRequest (pctxt, pvalue->data.
            u.obj_DetachRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_DLNASTransport:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DLNASTransport;

         pvalue->data.u.obj_DLNASTransport = rtxMemAllocType (pctxt, 
            TS24301Msg_DLNASTransport);

         if (pvalue->data.u.obj_DLNASTransport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_DLNASTransport (pvalue->data.u.obj_DLNASTransport
            );

         ret = NASDec_TS24301Msg_DLNASTransport (pctxt, pvalue->data.
            u.obj_DLNASTransport);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_EMMInformation:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_EMMInformation;

         pvalue->data.u.obj_EMMInformation = rtxMemAllocType (pctxt, 
            TS24301Msg_EMMInformation);

         if (pvalue->data.u.obj_EMMInformation == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_EMMInformation (pvalue->data.u.obj_EMMInformation
            );

         ret = NASDec_TS24301Msg_EMMInformation (pctxt, pvalue->data.
            u.obj_EMMInformation);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_EMMStatus:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_EMMStatus;

         ret = NASDec_TS24301Msg_EMMStatus (pctxt, &pvalue->data.
            u.obj_EMMStatus);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ExtServiceReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ExtServiceReq;

         pvalue->data.u.obj_ExtServiceReq = rtxMemAllocType (pctxt, 
            TS24301Msg_ExtServiceReq);

         if (pvalue->data.u.obj_ExtServiceReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ExtServiceReq (pvalue->data.u.obj_ExtServiceReq);

         ret = NASDec_TS24301Msg_ExtServiceReq (pctxt, pvalue->data.
            u.obj_ExtServiceReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_GUTIReallocCmd:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_GUTIReallocCmd;

         pvalue->data.u.obj_GUTIReallocCmd = rtxMemAllocType (pctxt, 
            TS24301Msg_GUTIReallocCmd);

         if (pvalue->data.u.obj_GUTIReallocCmd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_GUTIReallocCmd (pvalue->data.u.obj_GUTIReallocCmd
            );

         ret = NASDec_TS24301Msg_GUTIReallocCmd (pctxt, pvalue->data.
            u.obj_GUTIReallocCmd);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_GUTIReallocCmplt:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_GUTIReallocCmplt;

         break;

      case ASN1V_ts24301Msg_mt_IdentReq:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_IdentReq;

         pvalue->data.u.obj_IdentReq = rtxMemAllocType (pctxt, 
            TS24301Msg_IdentReq);

         if (pvalue->data.u.obj_IdentReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_IdentReq (pvalue->data.u.obj_IdentReq);

         ret = NASDec_TS24301Msg_IdentReq (pctxt, pvalue->data.u.obj_IdentReq
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_IdentResp:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_IdentResp;

         pvalue->data.u.obj_IdentResp = rtxMemAllocType (pctxt, 
            TS24301Msg_IdentResp);

         if (pvalue->data.u.obj_IdentResp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_IdentResp (pvalue->data.u.obj_IdentResp);

         ret = NASDec_TS24301Msg_IdentResp (pctxt, pvalue->data.u.obj_IdentResp
            );
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_SecModeCmd:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_SecModeCmd;

         pvalue->data.u.obj_SecModeCmd = rtxMemAllocType (pctxt, 
            TS24301Msg_SecModeCmd);

         if (pvalue->data.u.obj_SecModeCmd == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_SecModeCmd (pvalue->data.u.obj_SecModeCmd);

         ret = NASDec_TS24301Msg_SecModeCmd (pctxt, pvalue->data.
            u.obj_SecModeCmd);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_SecModeCmplt:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_SecModeCmplt;

         pvalue->data.u.obj_SecModeCmplt = rtxMemAllocType (pctxt, 
            TS24301Msg_SecModeCmplt);

         if (pvalue->data.u.obj_SecModeCmplt == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_SecModeCmplt (pvalue->data.u.obj_SecModeCmplt);

         ret = NASDec_TS24301Msg_SecModeCmplt (pctxt, pvalue->data.
            u.obj_SecModeCmplt);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_SecModeReject:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_SecModeReject;

         ret = NASDec_TS24301Msg_SecModeReject (pctxt, &pvalue->data.
            u.obj_SecModeReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ServiceReject:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ServiceReject;

         pvalue->data.u.obj_ServiceReject = rtxMemAllocType (pctxt, 
            TS24301Msg_ServiceReject);

         if (pvalue->data.u.obj_ServiceReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ServiceReject (pvalue->data.u.obj_ServiceReject);

         ret = NASDec_TS24301Msg_ServiceReject (pctxt, pvalue->data.
            u.obj_ServiceReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_TrkAreaUpdAccept:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_TrkAreaUpdAccept;

         pvalue->data.u.obj_TrkAreaUpdAccept = rtxMemAllocType (pctxt, 
            TS24301Msg_TrkAreaUpdAccept);

         if (pvalue->data.u.obj_TrkAreaUpdAccept == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_TrkAreaUpdAccept (pvalue->data.
            u.obj_TrkAreaUpdAccept);

         ret = NASDec_TS24301Msg_TrkAreaUpdAccept (pctxt, pvalue->data.
            u.obj_TrkAreaUpdAccept);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_TrkAreaUpdCmplt:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_TrkAreaUpdCmplt;

         break;

      case ASN1V_ts24301Msg_mt_TrkAreaUpdReject:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_TrkAreaUpdReject;

         pvalue->data.u.obj_TrkAreaUpdReject = rtxMemAllocType (pctxt, 
            TS24301Msg_TrkAreaUpdReject);

         if (pvalue->data.u.obj_TrkAreaUpdReject == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_TrkAreaUpdReject (pvalue->data.
            u.obj_TrkAreaUpdReject);

         ret = NASDec_TS24301Msg_TrkAreaUpdReject (pctxt, pvalue->data.
            u.obj_TrkAreaUpdReject);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_TrkAreaUpdRequest:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_TrkAreaUpdRequest;

         pvalue->data.u.obj_TrkAreaUpdRequest = rtxMemAllocType (pctxt, 
            TS24301Msg_TrkAreaUpdRequest);

         if (pvalue->data.u.obj_TrkAreaUpdRequest == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_TrkAreaUpdRequest (pvalue->data.
            u.obj_TrkAreaUpdRequest);

         ret = NASDec_TS24301Msg_TrkAreaUpdRequest (pctxt, pvalue->data.
            u.obj_TrkAreaUpdRequest);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ULNASTransport:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ULNASTransport;

         pvalue->data.u.obj_ULNASTransport = rtxMemAllocType (pctxt, 
            TS24301Msg_ULNASTransport);

         if (pvalue->data.u.obj_ULNASTransport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ULNASTransport (pvalue->data.u.obj_ULNASTransport
            );

         ret = NASDec_TS24301Msg_ULNASTransport (pctxt, pvalue->data.
            u.obj_ULNASTransport);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ULGenNASTransport:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ULGenNASTransport;

         pvalue->data.u.obj_ULGenNASTransport = rtxMemAllocType (pctxt, 
            TS24301Msg_ULGenNASTransport);

         if (pvalue->data.u.obj_ULGenNASTransport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ULGenNASTransport (pvalue->data.
            u.obj_ULGenNASTransport);

         ret = NASDec_TS24301Msg_ULGenNASTransport (pctxt, pvalue->data.
            u.obj_ULGenNASTransport);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_DLGenNASTransport:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DLGenNASTransport;

         pvalue->data.u.obj_DLGenNASTransport = rtxMemAllocType (pctxt, 
            TS24301Msg_DLGenNASTransport);

         if (pvalue->data.u.obj_DLGenNASTransport == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_DLGenNASTransport (pvalue->data.
            u.obj_DLGenNASTransport);

         ret = NASDec_TS24301Msg_DLGenNASTransport (pctxt, pvalue->data.
            u.obj_DLGenNASTransport);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   case TS24007L3_ProtoDiscr_epsSessMgmt:
      switch (pvalue->msgType) {
      case ASN1V_ts24301Msg_mt_ActvDedEPSBearerCtxtAcc:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDedEPSBearerCtxtAcc;

         pvalue->data.u.obj_ActvDedEPSBearerCtxtAcc = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDedEPSBearerCtxtAcc);

         if (pvalue->data.u.obj_ActvDedEPSBearerCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDedEPSBearerCtxtAcc (pvalue->data.
            u.obj_ActvDedEPSBearerCtxtAcc);

         ret = NASDec_TS24301Msg_ActvDedEPSBearerCtxtAcc (pctxt, pvalue->data.
            u.obj_ActvDedEPSBearerCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ActvDedEPSBearerCtxtRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDedEPSBearerCtxtRej;

         pvalue->data.u.obj_ActvDedEPSBearerCtxtRej = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDedEPSBearerCtxtRej);

         if (pvalue->data.u.obj_ActvDedEPSBearerCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDedEPSBearerCtxtRej (pvalue->data.
            u.obj_ActvDedEPSBearerCtxtRej);

         ret = NASDec_TS24301Msg_ActvDedEPSBearerCtxtRej (pctxt, pvalue->data.
            u.obj_ActvDedEPSBearerCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ActvDedEPSBearerCtxtReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDedEPSBearerCtxtReq;

         pvalue->data.u.obj_ActvDedEPSBearerCtxtReq = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDedEPSBearerCtxtReq);

         if (pvalue->data.u.obj_ActvDedEPSBearerCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDedEPSBearerCtxtReq (pvalue->data.
            u.obj_ActvDedEPSBearerCtxtReq);

         ret = NASDec_TS24301Msg_ActvDedEPSBearerCtxtReq (pctxt, pvalue->data.
            u.obj_ActvDedEPSBearerCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ActvDfltEPSBearerCtxtAcc:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDfltEPSBearerCtxtAcc;

         pvalue->data.u.obj_ActvDfltEPSBearerCtxtAcc = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDfltEPSBearerCtxtAcc);

         if (pvalue->data.u.obj_ActvDfltEPSBearerCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDfltEPSBearerCtxtAcc (pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtAcc);

         ret = NASDec_TS24301Msg_ActvDfltEPSBearerCtxtAcc (pctxt, pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ActvDfltEPSBearerCtxtRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDfltEPSBearerCtxtRej;

         pvalue->data.u.obj_ActvDfltEPSBearerCtxtRej = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDfltEPSBearerCtxtRej);

         if (pvalue->data.u.obj_ActvDfltEPSBearerCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDfltEPSBearerCtxtRej (pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtRej);

         ret = NASDec_TS24301Msg_ActvDfltEPSBearerCtxtRej (pctxt, pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ActvDfltEPSBearerCtxtReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ActvDfltEPSBearerCtxtReq;

         pvalue->data.u.obj_ActvDfltEPSBearerCtxtReq = rtxMemAllocType (pctxt, 
            TS24301Msg_ActvDfltEPSBearerCtxtReq);

         if (pvalue->data.u.obj_ActvDfltEPSBearerCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ActvDfltEPSBearerCtxtReq (pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtReq);

         ret = NASDec_TS24301Msg_ActvDfltEPSBearerCtxtReq (pctxt, pvalue->data.
            u.obj_ActvDfltEPSBearerCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_BearerResAllocRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_BearerResAllocRej;

         pvalue->data.u.obj_BearerResAllocRej = rtxMemAllocType (pctxt, 
            TS24301Msg_BearerResAllocRej);

         if (pvalue->data.u.obj_BearerResAllocRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_BearerResAllocRej (pvalue->data.
            u.obj_BearerResAllocRej);

         ret = NASDec_TS24301Msg_BearerResAllocRej (pctxt, pvalue->data.
            u.obj_BearerResAllocRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_BearerResAllocReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_BearerResAllocReq;

         pvalue->data.u.obj_BearerResAllocReq = rtxMemAllocType (pctxt, 
            TS24301Msg_BearerResAllocReq);

         if (pvalue->data.u.obj_BearerResAllocReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_BearerResAllocReq (pvalue->data.
            u.obj_BearerResAllocReq);

         ret = NASDec_TS24301Msg_BearerResAllocReq (pctxt, pvalue->data.
            u.obj_BearerResAllocReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_BearerResModRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_BearerResModRej;

         pvalue->data.u.obj_BearerResModRej = rtxMemAllocType (pctxt, 
            TS24301Msg_BearerResModRej);

         if (pvalue->data.u.obj_BearerResModRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_BearerResModRej (pvalue->data.
            u.obj_BearerResModRej);

         ret = NASDec_TS24301Msg_BearerResModRej (pctxt, pvalue->data.
            u.obj_BearerResModRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_BearerResModReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_BearerResModReq;

         pvalue->data.u.obj_BearerResModReq = rtxMemAllocType (pctxt, 
            TS24301Msg_BearerResModReq);

         if (pvalue->data.u.obj_BearerResModReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_BearerResModReq (pvalue->data.
            u.obj_BearerResModReq);

         ret = NASDec_TS24301Msg_BearerResModReq (pctxt, pvalue->data.
            u.obj_BearerResModReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_DeactEPSBearerCtxtAcc:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DeactEPSBearerCtxtAcc;

         pvalue->data.u.obj_DeactEPSBearerCtxtAcc = rtxMemAllocType (pctxt, 
            TS24301Msg_DeactEPSBearerCtxtAcc);

         if (pvalue->data.u.obj_DeactEPSBearerCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_DeactEPSBearerCtxtAcc (pvalue->data.
            u.obj_DeactEPSBearerCtxtAcc);

         ret = NASDec_TS24301Msg_DeactEPSBearerCtxtAcc (pctxt, pvalue->data.
            u.obj_DeactEPSBearerCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_DeactEPSBearerCtxtReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_DeactEPSBearerCtxtReq;

         pvalue->data.u.obj_DeactEPSBearerCtxtReq = rtxMemAllocType (pctxt, 
            TS24301Msg_DeactEPSBearerCtxtReq);

         if (pvalue->data.u.obj_DeactEPSBearerCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_DeactEPSBearerCtxtReq (pvalue->data.
            u.obj_DeactEPSBearerCtxtReq);

         ret = NASDec_TS24301Msg_DeactEPSBearerCtxtReq (pctxt, pvalue->data.
            u.obj_DeactEPSBearerCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ESMInfoReq:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ESMInfoReq;

         break;

      case ASN1V_ts24301Msg_mt_ESMInfoResp:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ESMInfoResp;

         pvalue->data.u.obj_ESMInfoResp = rtxMemAllocType (pctxt, 
            TS24301Msg_ESMInfoResp);

         if (pvalue->data.u.obj_ESMInfoResp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ESMInfoResp (pvalue->data.u.obj_ESMInfoResp);

         ret = NASDec_TS24301Msg_ESMInfoResp (pctxt, pvalue->data.
            u.obj_ESMInfoResp);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ESMStatus:
         pvalue->data.t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ESMStatus;

         ret = NASDec_TS24301Msg_ESMStatus (pctxt, &pvalue->data.
            u.obj_ESMStatus);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ModEPSBearerCtxtAcc:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ModEPSBearerCtxtAcc;

         pvalue->data.u.obj_ModEPSBearerCtxtAcc = rtxMemAllocType (pctxt, 
            TS24301Msg_ModEPSBearerCtxtAcc);

         if (pvalue->data.u.obj_ModEPSBearerCtxtAcc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ModEPSBearerCtxtAcc (pvalue->data.
            u.obj_ModEPSBearerCtxtAcc);

         ret = NASDec_TS24301Msg_ModEPSBearerCtxtAcc (pctxt, pvalue->data.
            u.obj_ModEPSBearerCtxtAcc);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ModEPSBearerCtxtRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ModEPSBearerCtxtRej;

         pvalue->data.u.obj_ModEPSBearerCtxtRej = rtxMemAllocType (pctxt, 
            TS24301Msg_ModEPSBearerCtxtRej);

         if (pvalue->data.u.obj_ModEPSBearerCtxtRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ModEPSBearerCtxtRej (pvalue->data.
            u.obj_ModEPSBearerCtxtRej);

         ret = NASDec_TS24301Msg_ModEPSBearerCtxtRej (pctxt, pvalue->data.
            u.obj_ModEPSBearerCtxtRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_ModEPSBearerCtxtReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_ModEPSBearerCtxtReq;

         pvalue->data.u.obj_ModEPSBearerCtxtReq = rtxMemAllocType (pctxt, 
            TS24301Msg_ModEPSBearerCtxtReq);

         if (pvalue->data.u.obj_ModEPSBearerCtxtReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_ModEPSBearerCtxtReq (pvalue->data.
            u.obj_ModEPSBearerCtxtReq);

         ret = NASDec_TS24301Msg_ModEPSBearerCtxtReq (pctxt, pvalue->data.
            u.obj_ModEPSBearerCtxtReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_PDNConnectRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_PDNConnectRej;

         pvalue->data.u.obj_PDNConnectRej = rtxMemAllocType (pctxt, 
            TS24301Msg_PDNConnectRej);

         if (pvalue->data.u.obj_PDNConnectRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_PDNConnectRej (pvalue->data.u.obj_PDNConnectRej);

         ret = NASDec_TS24301Msg_PDNConnectRej (pctxt, pvalue->data.
            u.obj_PDNConnectRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_PDNConnectReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_PDNConnectReq;

         pvalue->data.u.obj_PDNConnectReq = rtxMemAllocType (pctxt, 
            TS24301Msg_PDNConnectReq);

         if (pvalue->data.u.obj_PDNConnectReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_PDNConnectReq (pvalue->data.u.obj_PDNConnectReq);

         ret = NASDec_TS24301Msg_PDNConnectReq (pctxt, pvalue->data.
            u.obj_PDNConnectReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_PDNDisconnRej:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_PDNDisconnRej;

         pvalue->data.u.obj_PDNDisconnRej = rtxMemAllocType (pctxt, 
            TS24301Msg_PDNDisconnRej);

         if (pvalue->data.u.obj_PDNDisconnRej == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_PDNDisconnRej (pvalue->data.u.obj_PDNDisconnRej);

         ret = NASDec_TS24301Msg_PDNDisconnRej (pctxt, pvalue->data.
            u.obj_PDNDisconnRej);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      case ASN1V_ts24301Msg_mt_PDNDisconnReq:
         pvalue->data.
            t = T_TS24301Msgs_TS24301_IE_OBJECTSET_obj_PDNDisconnReq;

         pvalue->data.u.obj_PDNDisconnReq = rtxMemAllocType (pctxt, 
            TS24301Msg_PDNDisconnReq);

         if (pvalue->data.u.obj_PDNDisconnReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_TS24301Msg_PDNDisconnReq (pvalue->data.u.obj_PDNDisconnReq);

         ret = NASDec_TS24301Msg_PDNDisconnReq (pctxt, pvalue->data.
            u.obj_PDNDisconnReq);
         if (ret < 0) return LOG_RTERR (pctxt, ret);

         break;

      default:
         return RTERR_INVOPT;
      }

      break;

   default:
      return RTERR_INVOPT;
   }

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_ServiceRequest (OSCTXT* pctxt
   , TS24301Msg_ServiceRequest* pvalue)
{
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ServiceRequest");

   /* decode l3HdrOpts */

   RTXCTXTPUSHELEMNAME (pctxt, "l3HdrOpts");

   ret = NASDec_TS24007L3_L3HdrOptions (pctxt, &pvalue->l3HdrOpts);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode protoDiscr */

   RTXCTXTPUSHELEMNAME (pctxt, "protoDiscr");

   ret = NASDec_TS24007L3_ProtoDiscr (pctxt, &pvalue->protoDiscr);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode ksiAndSequenceNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "ksiAndSequenceNumber");

   ret = NASDec_TS24301IE_KSIAndSequenceNumber (pctxt, &pvalue->
      ksiAndSequenceNumber);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   /* decode shortMAC */

   RTXCTXTPUSHELEMNAME (pctxt, "shortMAC");

   ret = NASDec_TS24301IE_ShortMAC (pctxt, &pvalue->shortMAC);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTXCTXTPOPELEMNAME (pctxt);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

EXTERN int NASDec_TS24301Msg_Notification (OSCTXT* pctxt
   , TS24301Msg_Notification* pvalue)
{
   OSSIZE endIndex;
   int ret = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Notification");

   /* decode length */

   RTXCTXTPUSHELEMNAME (pctxt, "length");
   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxReadBytes (pctxt, &pvalue->length, 1);
   if (0 != ret) return LOG_RTERR (pctxt, ret);
   if (!(pvalue->length == 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->length);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   endIndex = pctxt->buffer.byteIndex + pvalue->length;

   RTDIAG_SETBITFLDCOUNT (pctxt);
   RTXCTXTPOPELEMNAME (pctxt);

   if (pctxt->buffer.byteIndex >= endIndex) return 0;

   /* decode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   RTDIAG_NEWBITFIELD (pctxt, "INTEGER");

   ret = rtxDecBitsToByte (pctxt, &pvalue->value, 8);
   if (ret < 0) return LOG_RTERR (pctxt, ret);

   RTDIAG_SETBITFLDCOUNT (pctxt);

   RTXCTXTPOPELEMNAME (pctxt);

   if (pctxt->buffer.byteIndex >= endIndex) return 0;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ret);
}

